<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu系统截图工具Flameshot安装</title>
    <url>/2021/06/21/Ubuntu%E7%B3%BB%E7%BB%9F%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7Flameshot%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<h4 id="习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（sudo-apt-install-flameshot）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。"><a href="#习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（sudo-apt-install-flameshot）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。" class="headerlink" title="习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（sudo apt install flameshot）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。"></a>习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（<code>sudo apt install flameshot</code>）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。</h4><span id="more"></span>
</blockquote>
<p>本文参考链接：<a href="https://blog.csdn.net/xiaoqiangclub/article/details/105516383">https://blog.csdn.net/xiaoqiangclub/article/details/105516383</a></p>
<p>先上两张图：</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621215841178.png" alt="image-20210621215841178"></p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621215934165.png" alt="image-20210621215934165"></p>
<h4 id="以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。"><a href="#以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。" class="headerlink" title="以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。"></a>以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。</h4><h2 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h2><h4 id="一、安装git，为后面克隆flameshot做准备"><a href="#一、安装git，为后面克隆flameshot做准备" class="headerlink" title="一、安装git，为后面克隆flameshot做准备"></a>一、安装git，为后面克隆flameshot做准备</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git </span><br></pre></td></tr></table></figure>



<h4 id="二、克隆项目到本地，我克隆到-home-sky-SoftWare-目录下。"><a href="#二、克隆项目到本地，我克隆到-home-sky-SoftWare-目录下。" class="headerlink" title="二、克隆项目到本地，我克隆到/home/sky/SoftWare/目录下。"></a>二、克隆项目到本地，我克隆到/home/sky/SoftWare/目录下。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo git clone https://github.com/lupoDharkael/flameshot.git</span><br></pre></td></tr></table></figure>



<h4 id="三、接下来是根据-github官方文档-的提示安装一些依赖库"><a href="#三、接下来是根据-github官方文档-的提示安装一些依赖库" class="headerlink" title="三、接下来是根据 github官方文档 的提示安装一些依赖库"></a>三、接下来是根据 <code>github官方文档</code> 的提示安装一些依赖库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Compile-time</span><br><span class="line">apt install g++ build-essential qt5-default qt5-qmake qttools5-dev-tools</span><br><span class="line"></span><br><span class="line"># Run-time</span><br><span class="line">apt install libqt5dbus5 libqt5network5 libqt5core5a libqt5widgets5 libqt5gui5 libqt5svg5-dev</span><br><span class="line"></span><br><span class="line"># Optional</span><br><span class="line">apt install git openssl ca-certificates</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621222006062.png" alt="image-20210621222006062"></p>
<h4 id="四、在克隆的目录（-home-sky-SoftWare-flameshot-）下进行编译："><a href="#四、在克隆的目录（-home-sky-SoftWare-flameshot-）下进行编译：" class="headerlink" title="四、在克隆的目录（/home/sky/SoftWare/flameshot/）下进行编译："></a>四、在克隆的目录（/home/sky/SoftWare/flameshot/）下进行编译：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>在这步有如果你用<code>sudo apt install cmake</code> 安装cmake，可能会遇到cmake版本过低的问题，在  <a href="https://cmake.org/files/">https://cmake.org/files/</a>   网站下载最新版本安装即可。</p>
<h4 id="五、编译完成之后执行命令sudo-make-install，安装完成！"><a href="#五、编译完成之后执行命令sudo-make-install，安装完成！" class="headerlink" title="五、编译完成之后执行命令sudo make install，安装完成！"></a>五、编译完成之后执行命令<code>sudo make install</code>，安装完成！</h4><h4 id="六、使用命令which-flameshot可以得到flameshot的位置"><a href="#六、使用命令which-flameshot可以得到flameshot的位置" class="headerlink" title="六、使用命令which flameshot可以得到flameshot的位置"></a>六、使用命令<code>which flameshot</code>可以得到flameshot的位置</h4><h4 id="七、在设置中添加自定义快捷键"><a href="#七、在设置中添加自定义快捷键" class="headerlink" title="七、在设置中添加自定义快捷键"></a>七、在设置中添加自定义快捷键</h4><p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621223410545.png" alt="image-20210621223410545"></p>
<h4 id="八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。"><a href="#八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。" class="headerlink" title="八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。"></a>八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。</h4><h3 id="到此，你就有一个完整版的flameshot使用了。"><a href="#到此，你就有一个完整版的flameshot使用了。" class="headerlink" title="到此，你就有一个完整版的flameshot使用了。"></a>到此，你就有一个完整版的flameshot使用了。</h3>]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>flameshot</tag>
        <tag>ubuntu</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title>git diff</title>
    <url>/2021/06/22/git-diff/</url>
    <content><![CDATA[<p>本篇文章介绍了地方法比较的说明，git diff常用参数，git diff里程碑比较和扩展用法。</p>
<span id="more"></span>

<h3 id="diff比较说明"><a href="#diff比较说明" class="headerlink" title="diff比较说明"></a>diff比较说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 --- hello       2020-09-21 17:45:33.551610940 +0800  </span><br><span class="line">2 +++ world       2020-09-21 17:44:46.343610465 +0800  </span><br><span class="line">3 @@ -1，4 +1，4 @@  </span><br><span class="line">4 -应该杜绝文章中的错别子。  </span><br><span class="line">5 +应该杜绝文章中的错别字。  </span><br><span class="line">6    </span><br><span class="line">7  但是无论使用</span><br><span class="line">8  * 全拼，双拼  </span><br><span class="line">9 @@ -6，6 +6，7 @@ </span><br><span class="line">10   </span><br><span class="line">11  是人就有可能犯错，软件更是如此。 </span><br><span class="line">12   </span><br><span class="line">13 -犯了错，就要扣工资！ </span><br><span class="line">14 - </span><br><span class="line">15  改正的成本可能会很高。 </span><br><span class="line">16 + </span><br><span class="line">17 +但是“只要眼球足够多，所有Bug都好捉”， </span><br><span class="line">18 +这就是开源的哲学之一。</span><br></pre></td></tr></table></figure>
<p>为了说明方便，为每一行增添了行号。</p>
<ul>
<li><p>第1行和第2行分别记录了原始文件和目标文件的文件名及时间戳。以三个减号（—）开始的行标识的是原始文件，以三个加号（+++）开始的行标识的是目标文件。</p>
</li>
<li><p>在比较内容中，以减号（-）开始的行是只出现在原始文件中的行，例如：第4、13、14行。</p>
</li>
<li><p>在比较内容中，以加号（+）开始的行是只出现在目标文件中的行，例如：第5行和16-18行。</p>
</li>
<li><p>在比较内容中，以空格开始的行，是在原始文件和目标文件中都出现的行，例如：第6-8、10-12和第15行。这些行是用作差异比较的上下文。</p>
</li>
<li><p>第3-8行是第一个差异小节。每个差异小节以一行差异定位语句开始。第3行就是一条差异定位语句，其前后分别用两个@进行标识。</p>
</li>
<li><p>第3行定位语句中-1，4的含义是：本差异小节的内容相当于原始文件的从第1行开始的4行。而第4、6、7、8行是原始文件中的内容，加起来刚好是4行。</p>
</li>
<li><p>第3行定位语句中+1，4的含义是：本差异小节的内容相当于目标文件的从第1行开始的4行。而第5、6、7、8行是目标文件中的内容，加起来刚好是4行。</p>
</li>
<li><p>因为命令diff是用于行比较的，所以即使改正了一个字，也显示为一整行的修改（参见差异文件第4、5行）。Git对diff进行了扩展，并且还提供一种逐词比较的差异比较方法。</p>
</li>
<li><p>第9-18行是第二个差异小节。第9行是一条差异定位语句。</p>
</li>
<li><p>第9行定位语句中-6，6的含义是：本差异小节的内容相当于原始文件的从第6行开始的6行。第10-15行是原始文件中的内容，加起来刚好是6行。</p>
</li>
<li><p>第9行定位语句中+6，7的含义是：本差异小节的内容相当于目标文件的从第6行开始的7行。而第10-12、15-18行是目标文件中的内容，加起来刚好是7行。</p>
</li>
</ul>
<h3 id="git-diff常用参数"><a href="#git-diff常用参数" class="headerlink" title="git diff常用参数"></a>git diff常用参数</h3><ol>
<li>不带任何选项和参数调用git diff显示工作区的最新改动，即工作区与提交任务（提交暂存区，stage）中相比的差异。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>将工作区和HEAD（当前工作分支）相比，会看到更多的差异。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure></li>
<li><p>通过参数–cached或–staged调用git diff命令，看到的是提交暂存区（提交任务，stage）和版本库中文件的差异。 </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210622112954.jpeg" alt="微信图片_20210622102452"></p>
<h3 id="git-diff里程碑比较"><a href="#git-diff里程碑比较" class="headerlink" title="git diff里程碑比较"></a>git diff里程碑比较</h3><ul>
<li>比较里程碑B和里程碑A，用命令：<code>git diff B A</code></li>
<li>比较工作区和里程碑A，用命令：<code>git diff A</code></li>
<li>比较暂存区和里程碑A，用命令：<code>git diff--cached A</code></li>
</ul>
<h3 id="git-diff扩展"><a href="#git-diff扩展" class="headerlink" title="git diff扩展"></a>git diff扩展</h3><ol>
<li><p>文件不同版本的差异比较差异比较还可以使用路径参数，只显示不同版本间该路径下文件的差异。语法格式如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; -- &lt;paths&gt;  </span><br></pre></td></tr></table></figure></li>
<li><p>非Git目录/文件的差异比较命令git diff还可以在Git版本库之外执行，对非Git目录进行比较，就像GNU的diff命令一样。之所以提供这个功能是因为Git差异比较命令更为强大，提供了对二进制文件差异等的扩展支持。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff &lt;path1&gt; &lt;path2&gt; </span><br></pre></td></tr></table></figure></li>
<li><p>逐词比较，而非默认的逐行比较Git的差异比较默认是逐行比较，分别显示改动前的行和改动后的行，到底改动在哪里还需要仔细辨别。Git还提供一种逐词比较的输出，有的人会更喜欢。使用–word-diff参数可以显示逐词比较。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --word-diff diff --git a/src/book/02-use-git/080-git-history-travel.rst b/src/book/02-use-git/080-git-history-travel.rst </span><br><span class="line">index f740203..2dd3e6f 100644 </span><br><span class="line">--- a/src/book/02-use-git/080-git-history-travel.rst </span><br><span class="line">+++ b/src/book/02-use-git/080-git-history-travel.rst </span><br><span class="line">@@ -681，7 +681，7 @@</span><br><span class="line">Git的大部分命令可以使用提交版本作为参数（如：git diff），</span><br><span class="line">::</span><br><span class="line">  [-18:23:48 jiangxin@hp:~/gitwork/gitbook/src/book$-]&#123;+$+&#125; </span><br><span class="line">git log --stat --oneline  I..C</span><br><span class="line">  0cd7f2e commit C.    </span><br><span class="line">    README    |    1 +</span><br><span class="line">    doc/C.txt |    1 +</span><br></pre></td></tr></table></figure>
<p>上面的逐词差异显示是有颜色的：删除内容[-…-]用红色表示，添加的内容{+…+}用绿色表示。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git diff</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages</title>
    <url>/2021/05/22/github-pages/</url>
    <content><![CDATA[<p>在用github和hexo搭建个人博客时遇到github pages。github pages是什么呢？它就是托管在github上的静态网页。建立时注意事项：</p>
<ol>
<li>仓库名和用户名相同</li>
<li>在仓库的setting找到page，把分支改为branch分支就行了</li>
</ol>
<span id="more"></span>



<h1 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h1><h3 id="1、什么是github-pages"><a href="#1、什么是github-pages" class="headerlink" title="1、什么是github pages"></a>1、什么是github pages</h3><ol>
<li>什么是github pages<br>github是项目托管网站，列出了项目的源文件，所以github 有一个pages功能，可以自定义主页，用来代替默认的列出源列表的这个页面</li>
</ol>
<blockquote>
<p>所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。</p>
</blockquote>
<ol start="2">
<li>下面是GitHub Pages 官方文档:</li>
</ol>
<p><a href="https://pages.github.com/">https://pages.github.com/</a><br><a href="http://help.github.com/pages">http://help.github.com/pages</a></p>
<ol start="3">
<li><p>GitHub提供两种类型的主页(<a href="https://help.github.com/articles/user-organization-and-project-pages">https://help.github.com/articles/user-organization-and-project-pages</a>):</p>
<ol>
<li>个人或组织主页 - 页面内容位于 main下</li>
<li>项目主页 - 页面内容位于每个项目的main下</li>
</ol>
<p>我们创建的博客属于个人页面（也可以创建为项目主页，不过默认的域名不一样，个人理解）</p>
</li>
</ol>
<h3 id="2、怎么使用github-pages"><a href="#2、怎么使用github-pages" class="headerlink" title="2、怎么使用github pages"></a>2、怎么使用github pages</h3><ol>
<li><p>使用个人或组织页面<br>使用个人或组织页面，需要先创建一个和你的账号同名的仓库，比我我的github账号是51228，那么我需要创建一个名为51228.github.io的repo，然后在master上提交你的项目代码，这样就可以通过网址：<a href="http://51228.github.io来访问我的个人博客./">http://51228.github.io来访问我的个人博客。</a></p>
</li>
<li><p>使用项目主页的方法如下</p>
<ol>
<li><p>设置的方法很简单，只需要在你项目的右上角点击setting</p>
</li>
<li><p>找到下方的pages，将默认的none改成main分支</p>
</li>
<li><p>点击保存，之后就可以在github pages后面看到你的项目链接了，你可以直接通过这个链接查看你main分支中代码的html内容</p>
</li>
</ol>
<blockquote>
<h4 id="user-pages只有一个-project-pages可以有多个-对于个人博客而言-两种方式都可以-如果用户申请了自己的域名-还可以使用CNAME文件自定义domain-name-这样访问你的域名就自动访问到github上的页面-用户也可以自定义404页面"><a href="#user-pages只有一个-project-pages可以有多个-对于个人博客而言-两种方式都可以-如果用户申请了自己的域名-还可以使用CNAME文件自定义domain-name-这样访问你的域名就自动访问到github上的页面-用户也可以自定义404页面" class="headerlink" title="user pages只有一个, project pages可以有多个, 对于个人博客而言, 两种方式都可以.如果用户申请了自己的域名, 还可以使用CNAME文件自定义domain name, 这样访问你的域名就自动访问到github上的页面. 用户也可以自定义404页面."></a>user pages只有一个, project pages可以有多个, 对于个人博客而言, 两种方式都可以.如果用户申请了自己的域名, 还可以使用CNAME文件自定义domain name, 这样访问你的域名就自动访问到github上的页面. 用户也可以自定义404页面.</h4></blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>git hub pages</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>git冲突合并</title>
    <url>/2021/06/20/git%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>在使用<code>git push</code>的过程中，经常会遇到一个问题，因为文件有冲突无法push。冲突有几种表现形式？冲突的解决方式？本文就是解决以上问题。</p>
<span id="more"></span>

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>一. <a href="#1">冲突类型</a></p>
<ol>
<li>自动合并</li>
<li>逻辑冲突</li>
<li>真正的冲突</li>
<li>冲突树</li>
</ol>
<p>二. <a href="#2">Git如何记录冲突</a></p>
<ol>
<li>git冲突是通过.git目录下的几个文件记录的：</li>
<li>版本库暂存区中则会记录冲突文件的多个不同版本，使用<code>git ls-files -s</code>命令查看</li>
<li>工作区的版本则可能同时包含了成功合并即冲突合并，其中冲突合并会用特殊的标记</li>
</ol>
<p>三. <a href="#3">冲突的解决</a></p>
<ol>
<li>手工编辑完成冲突解决</li>
<li>图形工具完成冲突解决</li>
</ol>
<p><a id=1>一. 冲突类型</a></p>
<ol>
<li>自动合并</li>
</ol>
<ul>
<li>修改不同的文件</li>
<li>修改相同文件的不同区域</li>
<li>同时更改文件名和文件内容</li>
</ul>
<ol start="2">
<li>逻辑冲突</li>
</ol>
<ul>
<li>典型的逻辑冲突是一个用户修改了一个文件的文件名，而另外的用户在其他文件中引用旧的文件名，这样的合并虽然能够成功但是包含着逻辑冲突。</li>
<li>一个用户修改了函数的返回值而另外的用户使用旧的函数的返回值，虽然能够成功但是存在逻辑冲突。</li>
</ul>
<ol start="3">
<li>冲突树</li>
</ol>
<ul>
<li>如果一个用户将某个文件改名，另外一个用户把文件改为另外一个名字，当两个用户提交合并操作时，产生冲突。这种因为文件名修改造成的冲突，称为树冲突。</li>
</ul>
<p><a id=2>二. Git如何记录冲突</a></p>
<ol>
<li>git冲突是通过.git目录下的几个文件记录的：</li>
</ol>
<ul>
<li>文件.git/MERGE_HEAD记录所合并的提交ID</li>
<li>文件.git/MERGE_MSG记录合并失败的信息</li>
<li>文件.git/MERGE_MODE标识合并状态</li>
<li>可以使用<code>cat .git/MERGE_HEAD</code>,<code>cat .git/MERGE_MSG</code>,<code>cat .git/MERGE_MODE</code>来访问。</li>
</ul>
<ol start="2">
<li><p>版本库暂存区中则会记录冲突文件的多个不同版本，使用<code>git ls-files -s</code>命令查看：</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210620202729446.png" alt="image-20210620202729446"></p>
</li>
</ol>
<p>在上面的输出中，每一行分为四个字段，前两个分别是文件的属性和SHAI哈希值。第三个字段暂存区编号，当合并冲突发生后，会用到0以上的暂存区编号。</p>
<ul>
<li>编号为1的暂存区用于保存冲突文件修改之前的副本，即冲突双方共同的祖先版本。</li>
<li>编号为2的暂存区用于保存当前冲突文件在当前分支中修改的副本。</li>
<li>编号为3的暂存区用于保存当前冲突文件在合并版本中修改的副本。</li>
<li>对暂存区三个副本的访问方式：git show :编号:文件名<ul>
<li>编号：1，2，3，</li>
<li>文件名：_config.yml</li>
</ul>
</li>
</ul>
<ol start="3">
<li>工作区的版本则可能同时包含了成功合并即冲突合并，其中冲突合并会用特殊的标记（&lt;&lt;&lt;&lt;&lt;&lt;======&gt;&gt;&gt;&gt;&gt;&gt;）进行标识：</li>
</ol>
<ul>
<li>特殊标识&lt;&lt;&lt;&lt;&lt;&lt;和======之间的内容是当前分支更改的内容。</li>
<li>特殊标识======和&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是所合并的版本更改的内容。</li>
</ul>
<p><a id=3>三. 冲突的解决</a><br>冲突解决的实质就是通过编辑操作，将冲突标识符所标识的冲突内容替换为合适的内容，并去掉冲突标识符。编辑完成后执行<code>git add</code>命令将文件添加到暂存区（标号0）,然后再提交就完成了冲突解决。</p>
<ol>
<li><p>手工编辑完成冲突解决</p>
<ul>
<li><p>找到冲突的地方</p>
</li>
<li><p>在工作区编辑文件冲突的地方</p>
</li>
<li><p><code>git add -u</code>，添加到暂存区</p>
</li>
<li><p><code>git commit -m &quot;冲突解决&quot;</code>,提交完成后，.git目录下与合并相关的文件.git/MERGE_HEAD、.git/MERGE_MSG、.git/MERGE_MODE文件都自动删除。</p>
</li>
<li><p>执行推送</p>
</li>
</ul>
</li>
<li><p>图形工具完成冲突解决</p>
<p>第一步： 在操作系统中安装图形工具：kdiff3，meld，araxis等</p>
<p>第二步： 执行命令<code>git mergetool</code>后，会显示支持的图形工具列表。</p>
<p>第三步：启动kdiff3后，上方窗口从左至右显示冲突文件的三个版本，分别是：</p>
<p>​                A：暂存区1中的版本（共同的先祖版本）</p>
<p>​                B：暂存区2中的版本（当前分支更改的版本）</p>
<p>​                C：暂存区3中的版本（他人更改的版本）<img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210620212217851.png" alt="image-20210620212217851"></p>
</li>
</ol>
<p>  第四步：点击标记为“合并冲突”的一行，在弹出的菜单中出现A/B/C三个选项，分别代表从A、B、C三个窗口复制相关内容到当前位置<br>  第五步：B行代表从窗口B中复制的文件，M指手工修改的行<br>    <img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210620213323429.png" alt="image-20210620213323429"></p>
<p>  第六步：编辑完成后保存退出即完成图形化冲突解决。</p>
<p>  第七步：<code>git status</code>显示工作区状态，会看到冲突已经解决，在工作区会遗留一个以.orig结尾的合并前的文件副本,暂存区中三个文件的副本也已经清除。</p>
<p>  第八步：执行提交和推送，由于文件是在暂存区更改，所以不需要add，直接commit，再push。</p>
<ol start="3">
<li>树冲突可以采用手工操作和图形操作</li>
</ol>
<ul>
<li><p>手工操作由用户决定删除文件，保留一个文件而解决冲突。<code>git rm 文件名</code>。</p>
</li>
<li><p>图形模式交互式解决树冲突：执行<code>git mergetool</code>命令，忽略其中的提示和警告——&gt;询问对冲突文件的处理方式——&gt;输入D删除冲突文件，输入C保留冲突文件——&gt;最终解决冲突提交。</p>
</li>
</ul>
<hr>
<h3 id="总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先pull的习惯，编辑完文件再提交，减少冲突发生。"><a href="#总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先pull的习惯，编辑完文件再提交，减少冲突发生。" class="headerlink" title="总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先pull的习惯，编辑完文件再提交，减少冲突发生。"></a>总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先<code>pull</code>的习惯，编辑完文件再提交，减少冲突发生。</h3>]]></content>
      <categories>
        <category>知识点</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>冲突解决</tag>
        <tag>merge</tag>
      </tags>
  </entry>
  <entry>
    <title>git疑难之一(中文显示问题）</title>
    <url>/2021/06/23/git%E7%96%91%E9%9A%BE%E4%B9%8B%E4%B8%80(%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<p>解决git中文显示问题</p>
<span id="more"></span>





<ol>
<li><p>git输出文件名时，文件名的中文不能正确显示，而是显示为八进制的字符编码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status -s </span><br><span class="line">?? &quot;\350\257\264\346\230\216.txt&quot; $ printf &quot;\350\257\264\346\230\216.txt\n&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <font size=5 color=red>解决办法：</font></p>
<p>将git配置变量core.quotepath设置为false，就可以解决文件名中的中文在这些git输出中的显示问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath false  </span><br><span class="line">git config --global core.quotepath off       #用这个也可以</span><br></pre></td></tr></table></figure>



<p><font color=blue><strong>扩展</strong>：</font></p>
<ul>
<li><p>使用以下命令，提交命令的时候使用utf-8编码集提交，这样在使用<code>git commit</code>，commit对象中嵌入正确的编码说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global i18n.commitEncoding utf-8</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>使用以下命令，将提交说明所使用的字符集设置为utf-8，这样使用<code>git log</code>查看提交说明时才能够正确显示其中的中文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global i18n.logOutputEncoding utf-8</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>中文显示</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title># git问题之二—git提示“warning: LF will be replaced by CRLF”的解决办法</title>
    <url>/2021/06/24/git%E9%97%AE%E9%A2%98%E4%B9%8B%E4%BA%8C%E2%80%94git%E6%8F%90%E7%A4%BA%E2%80%9Cwarning%20LF%20will%20be%20replaced%20by%20CRLF%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>windows平台下使用git add，git deploy 文件时经常出现“warning: LF will be replaced by CRLF” 的提示。</p>
</blockquote>
<span id="more"></span>



<blockquote>
<p><strong>参考</strong>：<a href="https://blog.csdn.net/u012757419/article/details/105614028/">https://blog.csdn.net/u012757419/article/details/105614028/</a></p>
</blockquote>
<h4 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h4><p><font size=4 color=red>windows平台下使用git add，git deploy 文件时经常出现“warning: LF will be replaced by CRLF” 的提示。</p>
</font>

<h4 id="二、分析问题"><a href="#二、分析问题" class="headerlink" title="二、分析问题"></a>二、分析问题</h4><p>其实，这是因为在文本处理中，CR（CarriageReturn），LF（LineFeed），CR/LF是不同操作系统上使用的换行符，具体如下：</p>
<p>换行符‘\n’和回车符‘\r’</p>
<ul>
<li>回车符就是回到一行的开头，用符号r表示，十进制ASCII代码是13，十六进制代码为0x0D，回车（return）；</li>
<li>换行符就是另起一行，用n符号表示，ASCII代码是10，十六制为0x0A， 换行（newline）。</li>
</ul>
<p>所以我们平时编写文件的回车符应该确切来说叫做回车换行符。</p>
<p>应用情况</p>
<ul>
<li>Dos和Windows平台： 使用回车（CR）和换行（LF）两个字符来结束一行，回车+换行(CR+LF)，即“\r\n”；</li>
<li>Mac 和 Linux平台：只使用换行（LF）一个字符来结束一行，即“\n”；</li>
<li>最早Mac每行结尾是回车CR 即’\r’，后mac os x 也投奔了 unix。</li>
</ul>
<p>许多 Windows 上的编辑器会悄悄把行尾的换行（LF）字符转换成回车（CR）和换行（LF），或在用户按下 Enter 键时，插入回车（CR）和换行（LF）两个字符。</p>
<p>影响：</p>
<ul>
<li>一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；</li>
<li>而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</li>
<li>Linux保存的文件在windows上用记事本看的话会出现黑点。</li>
</ul>
<p>这些问题都可以通过一定方式进行转换统一，例如，在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。</p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a><font color=red>解决办法：</font></h4><h5 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h5><p>Git 可以在你提交时自动地把回车（CR）和换行（LF）转换成换行（LF），而在检出代码时把换行（LF）转换成回车（CR）和换行（LF）。 你可以用 git config –global core.autocrlf true 来打开此项功能。 如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#提交时转换为LF，检出时转换为CRLF</span><br><span class="line">$ git config --global core.autocrlf true</span><br></pre></td></tr></table></figure>



<h5 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h5><p>如果使用以换行（LF）作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换。然而当一个以回车（CR）和换行（LF）作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 所以，你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：（这样在 Windows 上的检出文件中会保留回车和换行，而在 Mac 和 Linux 上，以及版本库中会保留换行。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#提交时转换为LF，检出时不转换</span><br><span class="line">$ git config --global core.autocrlf input</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="情况三："><a href="#情况三：" class="headerlink" title="情况三："></a>情况三：</h5><p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#提交检出均不转换</span><br><span class="line">$ git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>




<p>你也可以在文件提交时进行safecrlf检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#拒绝提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf true   </span><br><span class="line"></span><br><span class="line">#允许提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf false   </span><br><span class="line"></span><br><span class="line">#提交包含混合换行符的文件时给出警告</span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>



<h4 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h4><ul>
<li><blockquote>
<p><font size=4 color=purple>git 的 Windows 客户端基本都会默认设置 core.autocrlf=true，设置core.autocrlf=true, 只要保持工作区都是纯 CRLF 文件，编辑器用 CRLF 换行，就不会出现警告了；</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4 color=purple>Linux 最好不要设置 core.autocrlf，因为这个配置算是为 Windows 平台定制；</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4 color=purple>Windows 上设置 core.autocrlf=false，仓库里也没有配置 .gitattributes，很容易引入 CRLF 或者混合换行符（Mixed Line Endings，一个文件里既有 LF 又有CRLF）到版本库，这样就可能产生各种奇怪的问题。</font></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>LF</tag>
        <tag>CR</tag>
        <tag>git add</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署的原理和步骤</title>
    <url>/2021/05/23/hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<blockquote>
<h4 id="Hexo-是一个快速、简洁且高效的博客框架。Hexo-使用-Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。"><a href="#Hexo-是一个快速、简洁且高效的博客框架。Hexo-使用-Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。" class="headerlink" title="Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。"></a>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</h4></blockquote>
<span id="more"></span>



<h1 id="hexo部署的原理和步骤"><a href="#hexo部署的原理和步骤" class="headerlink" title="hexo部署的原理和步骤"></a>hexo部署的原理和步骤</h1><hr>
<h2 id="本文将从以下几个方面尝试分析。"><a href="#本文将从以下几个方面尝试分析。" class="headerlink" title="本文将从以下几个方面尝试分析。"></a>本文将从以下几个方面尝试分析。</h2><ul>
<li><p>hexo原理</p>
<ul>
<li>hexo的文件夹结构</li>
<li>hexo的工作原理</li>
</ul>
</li>
<li><p>hexo模板引擎</p>
<ul>
<li>hexo的模板引擎</li>
<li>数据填充</li>
<li>使用yaml编写的配置文件</li>
<li>配置文件中数据的使用</li>
<li>使用markdown编写的博客文章</li>
</ul>
</li>
<li><p>hexo发布</p>
</li>
<li><p>hexo常用命令</p>
</li>
<li><p>hexo变量</p>
<ul>
<li><p>hexo变量</p>
</li>
<li><p>页面变量</p>
</li>
<li><p>Post(post) 变量</p>
</li>
<li><p> 首页(index)</p>
</li>
<li><p> 归档页(archive)</p>
</li>
</ul>
</li>
</ul>
<h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><p>内容是一个博客的灵魂。</p>
<h4 id="1-hexo的文件夹结构"><a href="#1-hexo的文件夹结构" class="headerlink" title="1. hexo的文件夹结构"></a>1. hexo的文件夹结构</h4><p>├── _config.yml<br>├── db.json<br>├── node_modules<br>├── package.json<br>├── public<br>├── scaffolds<br>├── source #所有文章文件放在这里<br>└── themes #主题文件夹</p>
<ul>
<li><p><strong>_config.yml</strong>：该文件是hexo 的<code>站</code>级配置文件。所谓站级配置文件是指，对整个站点起效果的配置文件。</p>
</li>
<li><p><strong>source目录</strong>：该目录存放源文件。即用户编写的博文都放在该目录下。在该目录下又有几个子目录我们来分别看一下。</p>
<ul>
<li><p><strong>_post</strong>：用于存放博文，基本上每篇文章都是由Markdown语法编写的。</p>
</li>
<li><p><strong>tags</strong>：存放tag 的文件。hexo中的tags是自动生成的，所以我们不用手动修改tags目录下的index.md文件，在发布时它会自动生成。</p>
</li>
<li><p><strong>categories</strong>：存放<strong>分类</strong>。它与tags是类似的，也是自动生成的，所以不需要我们手工修改。</p>
</li>
</ul>
</li>
<li><p><strong>themes目录</strong>：该目录用于存放主题，目前hexo中最热门的主题就是<strong>next</strong>了。最近的 next release 版本是 7.8 。</p>
</li>
<li><p><strong>public目录</strong>：该目录存放hexo转出的文件，如html、css、js等。</p>
</li>
<li><p><strong>scaffolds目录</strong>：它里面存放了一些<strong>“脚手架”</strong>程序，用于生成模板页面，如执行<code>hexo new &quot;title&quot;</code>时，就会生成一个Markdown文件模板。</p>
</li>
<li><p><strong>db.json</strong> ： 缓存文件</p>
</li>
<li><p><strong>node_modules</strong>：  安装的插件以及hexo所需的一些node.js模块。</p>
</li>
<li><p><strong>package.json</strong>： 应用程序信息，配置hexo运行需要的js包。</p>
</li>
</ul>
<h4 id="2-Hexo-的工作原理"><a href="#2-Hexo-的工作原理" class="headerlink" title="2. Hexo 的工作原理"></a>2. Hexo 的工作原理</h4><h5 id="1-hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步"><a href="#1-hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步" class="headerlink" title="1) hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:"></a>1) hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:</h5><ul>
<li>第一步，将Markdown翻译成下面格式的JSON对象：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">article: &#123;</span><br><span class="line">  title:</span><br><span class="line">  date:</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line">  content:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，根据上面生成的JSON对象生成 HTML 页面。</p>
<p>对于我们来说，清楚了上面hexo将Markdown转HTML页面的过程后，我们就很容易理解hexo 在执行不同命令时它都在做什么事儿了。</p>
<p>下面我们再来看看<strong>hexo</strong>的组成，它由三部分组成: <strong>hexo-cli</strong>、<strong>hexo-core</strong>以及<strong>hexo plugs</strong>。在这三部分中最核心的是hexo-core模块，它的作用就是执行上面讲的两步转换，从而生成目标文件；hexo-cli为我们供了一些非常方便的命令。当我们敲入命令时，它会根据命令调用不同的模块；hexo plugin是hexo的扩展，当hexo本身不能完成某项任务时，它允许你自己开发一个插件来完成。当然你也可以使用其它人写好的插件。</p>
<h5 id="2-这里我们来分析一下-Hexo-每次部署的流程"><a href="#2-这里我们来分析一下-Hexo-每次部署的流程" class="headerlink" title="2) 这里我们来分析一下 Hexo 每次部署的流程"></a>2) 这里我们来分析一下 Hexo 每次部署的流程</h5><ol>
<li>hexo g：生成静态文件。将我们的数据和界面相结合生成静态文件的过程：会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</li>
<li>hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</li>
<li>在node_modules中有一系列的文件用于对hexo中的各类页面进行默认的渲染，如果要启动个性化主页，需要删除hexo-generator-index,同时，将主题目录下的source目录作为你个性化页面的根目录。</li>
</ol>
<h2 id="二、模板引擎"><a href="#二、模板引擎" class="headerlink" title="二、模板引擎"></a>二、模板引擎</h2><p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p>
<h4 id="1-hexo的模板引擎"><a href="#1-hexo的模板引擎" class="headerlink" title="1. hexo的模板引擎"></a>1. hexo的模板引擎</h4><ul>
<li><p>我们可以注意到，在 Hexo 中，source 文件夹和 themes 文件夹是在同级的，我们就可以将 source 文件夹理解为数据库，而主题文件夹相当于 界面。然后我们 hexo g 就将我们的数据和界面相结合生成静态文件 public。</p>
</li>
<li><p>hexo默认的是使用ejs，同类型的东西还有很多，比如jade，swig。我选用主题是用jade的。hexo首先会解析md文件，然后根据layout判断布局类型，再调用其他的文件，这样每一块的  内容都是独立的，提高代码的复用性。最终会生成一个html页面。</p>
</li>
<li><p>jade采用缩进语法格式，和python比较类似，看上去也很舒服，我比较喜欢这种风格。在hexo中使用jade需要安装相应的模块，否则无法使用。</p>
</li>
<li><p>模板文件在 layout 文件夹下，layout 文件文档结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── _custom                           #通用布局</span><br><span class="line">├── _layout.swig                      #默认布局布局</span><br><span class="line">├── _macro                            #插件模板</span><br><span class="line">├── _partials                         #局部布局</span><br><span class="line">├── _scripts                         # script模板</span><br><span class="line">├── _third-party                      # 第三方插件模板</span><br><span class="line">├── archive.swig                      # 归档模板</span><br><span class="line">├── category.swig                     # 分类模板</span><br><span class="line">├── index.swig                        # 首页模板</span><br><span class="line">├── page.swig                         # 其他模板</span><br><span class="line">├── photo.swig                        # 照片模板（自定义）</span><br><span class="line">├── post.swig                         #文章模板</span><br><span class="line">├── schedule.swig                   # 归档模板</span><br><span class="line">└── tag.swig                          #标签模板</span><br></pre></td></tr></table></figure></li>
<li><p>每个模板都默认使用layout布局，您可在文章的前置申明中指定其他布局，比如“post”或者“page”或是设为false来关闭布局功能（如果不填默认是post，这个在_config.yml中可以设置默认值），您甚至可在布局中再使用其他布局来建立嵌套布局。</p>
</li>
<li><p>在我们新建页面或者新建文章的使用可以选定我们使用的模板。<code>hexo new [layout] &lt;title&gt;</code>就会使用对应的模板。</p>
</li>
<li><p> 其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</p>
</li>
</ul>
<h4 id="2-数据的填充"><a href="#2-数据的填充" class="headerlink" title="2. 数据的填充"></a>2. 数据的填充</h4><p>数据的填充主要是 hexo -g 的时候将数据传递给 swig 模板，然后再由 swig 模板填充到 HTML 中。</p>
<h4 id="3-使用yaml编写的配置文件"><a href="#3-使用yaml编写的配置文件" class="headerlink" title="3. 使用yaml编写的配置文件"></a>3. 使用yaml编写的配置文件</h4><ul>
<li><p>yaml是专门用来写配置文件的语言。它用首行缩进表示层级关系，便于读写理解。</p>
</li>
<li><p>配置文件一般用来对所需环境进行设置。hexo中涉及到两个配置文件，一个是位于主目录下的，另一个是位于主题目录下的。</p>
</li>
<li><p>通常主目录下的配置文件用于对全站的配置，比如站点的基本信息，文章的布局，写作的格式，部署到github上的参数等等。</p>
</li>
<li><p>而主题目录下的配置文件用于对该主题的配置，比如站点导航栏的设置，一些插件的设置等。</p>
</li>
</ul>
<p>Hexo 的配置文件 _config.yml 使用 yml语法 。例如博客的名字、副标题等等之类。这些数据项组织在 config 对象中。可以数字、字符串、对象、数组。</p>
<h4 id="4-配置文件中数据的使用"><a href="#4-配置文件中数据的使用" class="headerlink" title="4. 配置文件中数据的使用"></a>4. 配置文件中数据的使用</h4><p>如果要在模板中使用某个具体的值，比如字符串、数字、逻辑变量或者对象的某个成员，可以在主题的模板文件 swig 中直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; page.title &#125;&#125; | &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-使用markdown编写的博客文章"><a href="#5-使用markdown编写的博客文章" class="headerlink" title="5. 使用markdown编写的博客文章"></a>5. 使用markdown编写的博客文章</h4><p>之所以选择hexo做博客一个原因就是它支持markdown。用markdown写文章感觉特别爽，只需要记住简单的几个语法，而且可以把全部的注意力放在文字本身上，而不用去过多的关注排版。</p>
<h2 id="三、hexo发布页面"><a href="#三、hexo发布页面" class="headerlink" title="三、hexo发布页面"></a>三、<strong>hexo发布页面</strong></h2><p>我们可以使用<code>hexo d</code>命令将生成的目标文件发布出来，但在使用它之前，你需要在站节点的_config.yml文件中配置发布的方法。我们举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git #leancloud_counter_security_sync #git</span><br><span class="line">  repo: git@github.com:avdance/avdance.github.io.git</span><br></pre></td></tr></table></figure>

<p>当我们执行<code>hexo d</code>命令时，它会调用 hexo 中的 <code>hexo-deployer-git</code> 插件。在该插件内部会启动一个进程调用<code>git</code>命令，从而将生成的html等代码上传到 github上。</p>
<p>这里可能有些同学会有疑问，为什么上传到github上就算是发布了呢？这是因为github为我们提供了免费的个人博客空间。只要你在github上创建一个<code>用户名.github.io</code>的项目，github就会自动将这个项目中的文件发布出来。</p>
<p>当然你也可以采用传输的方式，自己购买台云主机，然后在云主机上用ngnix、nodejs等搭建一个Web服务，最终将页面发布出来。</p>
<h2 id="四、hexo的常用命令"><a href="#四、hexo的常用命令" class="headerlink" title="四、hexo的常用命令"></a>四、<strong>hexo的常用命令</strong></h2><p><strong>hexo</strong> 提供了几个常用命令，如<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>等等。下面我们分别看一下这几个命令的具体作用是什么：</p>
<ul>
<li>hexo clean: 删除 hexo 生成的所有文档。当我们执行这个命令后，你会发现public目录被删除了。</li>
<li>hexo g: 根据 source 目录中的文件生成html等可以发布的文件。</li>
<li>hexo s: 在本地起动 <strong>http</strong> 服务，将生成的 html 等输出文件布署到本地服务器上。</li>
<li>hexo d: 将生成的html代码推送到 github 上</li>
</ul>
<h2 id="五、Hexo-中的变量"><a href="#五、Hexo-中的变量" class="headerlink" title="五、Hexo 中的变量"></a>五、Hexo 中的变量</h2><h4 id="1、Hexo-中的变量"><a href="#1、Hexo-中的变量" class="headerlink" title="1、Hexo 中的变量"></a>1、Hexo 中的变量</h4><p>Hexo 提供了很多的变量，比如我们上面使用的 page 变量，还有 site 变量等，这些都是Hexo 提供的，我们可以拿来直接使用的，常用的变量有：</p>
<ul>
<li>site：对应整个网站的变量，一般会用到 site.posts.length 制作分页器。</li>
</ul>
<ol>
<li>site.posts 所有文章</li>
<li>site.pages 所有分页</li>
<li>site.categories 所有分类</li>
<li>site.tags 所有标签</li>
</ol>
<ul>
<li>page：存放当前页面的信息，例如我在 index.ejs 中使用 page.posts 获取了当前页面的所有文章而不是使用 site.posts。</li>
<li>config：config 变量我们在主目录下配置文件 _config.yml 中保存的信息。</li>
<li>theme：theme 变量是我们在主题目录下配置文件 _config.yml 中保存的信息。</li>
<li>path：当前页面的路径（不含根路径）。</li>
<li>url：页面完整网址。</li>
</ul>
<h4 id="2、页面变量"><a href="#2、页面变量" class="headerlink" title="2、页面变量"></a>2、页面变量</h4><p>Page(page) 这里指的是<code>hexo new page</code>创建的那个页面</p>
<ul>
<li>page.title：文章标题</li>
<li><a href="https://link.zhihu.com/?target=http://page.date">page.date</a>：文章建立日期</li>
<li>page.updated：文章更新日期</li>
<li>page.comments：留言是否开启</li>
<li>page.layout：布局名称</li>
<li>page.content：文章完整内容</li>
<li>page.excerpt：文章摘要</li>
<li>page.more：除了摘要的其他内容</li>
<li>page.source：文章原始路劲</li>
<li>page.full_source：文章完整原始路径</li>
<li>page.path：文章网址（不含根路径），通常在主题中使用url_for(page.path)</li>
<li>page.permalink：文章永久网址</li>
<li>page.prev：上一篇文章，如果此为第一篇文章则为null</li>
<li><a href="https://link.zhihu.com/?target=http://page.next">page.next</a>：下一篇文章，如果此为最后一篇文章则为null</li>
<li>page.raw：文章原始内容</li>
<li><a href="https://link.zhihu.com/?target=http://page.photos">page.photos</a>：文章的照片（用于相册）</li>
<li><a href="https://link.zhihu.com/?target=http://page.link">page.link</a>：文章的外链（用于链接文章）</li>
</ul>
<h4 id="3、Post-post-变量"><a href="#3、Post-post-变量" class="headerlink" title="3、Post(post) 变量"></a>3、Post(post) 变量</h4><p>这里指的是文章页面，与page布局相同，添加如下变量：</p>
<ul>
<li>page.pulished：文章非草稿为true</li>
<li>page.categories：文章分类</li>
<li>page.tags：文章标签</li>
</ul>
<h4 id="4、首页-index"><a href="#4、首页-index" class="headerlink" title="4、首页(index)"></a>4、首页(index)</h4><ul>
<li>page.per_page：每一页显示的文章数</li>
<li><a href="https://link.zhihu.com/?target=http://page.total">page.total</a>：文章数量</li>
<li>page.current：当前页码</li>
<li>page.current_url：当前页的URL</li>
<li>page.posts：当前页的文章</li>
<li>page.prev：前一页页码，如果为第一页，该值为0</li>
<li>page.prev_link：前一页URL，如果为第一页，则为’’</li>
<li><a href="https://link.zhihu.com/?target=http://page.next">page.next</a>：后一页页码，如果为最后一页，则为0</li>
<li>page.next_link：后一页URL，如果为最后一页，则为’’</li>
<li>page.path：当前页网址（不含根路径），通常在主题中使用url_for(page.path)</li>
</ul>
<h4 id="5、归档页-archive"><a href="#5、归档页-archive" class="headerlink" title="5、归档页(archive)"></a>5、归档页(archive)</h4><p>与index布局相同，但是新增如下变量：</p>
<ul>
<li><code>archive</code> 为true</li>
<li><code>year</code> 归档年份（4位）</li>
<li><code>month</code> 归档月份（不包含0）</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown如何实现锚点功能</title>
    <url>/2021/06/20/markdown%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%94%9A%E7%82%B9%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>之前看了几片文章， markdown 里面设置锚点步骤及用法都比较模糊，经过实验，将markdown锚点方法做如下分享。</p>
<span id="more"></span>

<p>参考链接：</p>
<blockquote>
<p><a href="https://blog.csdn.net/wangzhibo666/article/details/88731227">https://blog.csdn.net/wangzhibo666/article/details/88731227</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_41910694/article/details/91629999">https://blog.csdn.net/weixin_41910694/article/details/91629999</a></p>
</blockquote>
<p><a href="#qianyan">前言</a></p>
<p><a href="#fangfa">方法</a></p>
<p><a href="#cankao">参考</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="qianyan">前言</a></h2><p>之前看了几片文章， markdown 里面设置锚点步骤及用法都比较模糊，经过实验，将markdown锚点方法做如下分享。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><span id="fangfa">方法</span></h2><p>MarkDown页面内跳转语法</p>
<p>方法一:</p>
<ul>
<li>第一步:在需要跳转到的位置添加锚点，语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步:在需要点击跳转的位置，使用上面的id，格式类似超链接的形式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转](#jump)</span><br></pre></td></tr></table></figure>

<p>方法二:</p>
<p>第一步:在需要跳转到的位置添加锚点，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#测试2&quot;&gt;测试2&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>第二步:在需要点击跳转的位置，使用上面的id，格式类似超链接的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a id=&quot;测试2&quot;&gt;测试2&lt;/a&gt;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a id="cankao">参考</a></h2><p>[Markdown]页面添加锚点,跳到本页指定位置</p>
<h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 标题</span><br><span class="line"></span><br><span class="line">## 目录</span><br><span class="line">1. [目录1](#jump1)</span><br><span class="line">2. [目录2](#jump2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &lt;span id=&quot;jump1&quot;&gt;1. 目录1&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">### &lt;span id=&quot;jump2&quot;&gt;2. 目录2&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>应用</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>锚点</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml语法</title>
    <url>/2021/05/22/yaml%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在用hexo和github搭建博客的过程中遇到config.yml文件，这种文件的格式看起来非常简单明了，但这个文件到处都是坑，最大的坑是冒号“：”后的空格；缩进的空格。</p>
<span id="more"></span>


<h3 id="一、yaml语法简介："><a href="#一、yaml语法简介：" class="headerlink" title="一、yaml语法简介："></a>一、yaml语法简介：</h3><p>YAML（/ˈjæməl/，尾音类似 camel 骆驼）是一个可读性高，用来表达数据序列化的格式。YAML 参考了其他多种语言，包括： C 语言、 Python、Perl，并从 XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans 在 2001 年首次发表了这种语言 ，另外 Ingy döt Net 与 Oren Ben-Kiki 也是这语言的共同设计者 。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。</p>
<p>YAML (YAML Aint Markup Language)是一种标记语言，通常以.yml或者.yaml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。</p>
<h3 id="二、YML的优点"><a href="#二、YML的优点" class="headerlink" title="二、YML的优点"></a>二、YML的优点</h3><ol>
<li>YAML易于人们阅读。</li>
<li>YAML数据在编程语言之间是可移植的。</li>
<li>YAML匹配敏捷语言的本机数据结构。</li>
<li>YAML具有一致的模型来支持通用工具。</li>
<li>YAML支持单程处理。</li>
<li>YAML具有表现力和可扩展性。</li>
<li>YAML易于实现和使用。</li>
</ol>
<h3 id="三、YML语法"><a href="#三、YML语法" class="headerlink" title="三、YML语法"></a>三、YML语法</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.<strong>语法</strong></h4><ul>
<li>k: v 表示键值对关系，<strong>冒号后面必须有一个空格</strong></li>
<li>使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是同一个层级的</li>
<li>大小写敏感</li>
<li><em><strong>缩进时不允许使用Tab键，只允许使用空格。</strong></em></li>
<li>YAML 使用可打印的 Unicode 字符，可使用 UTF-8 或 UTF-16。</li>
<li>注解由井字号（ # ）开始，可以出现在一行中的任何位置，而且范围只有一行（也就是一般所谓的单行注解）</li>
<li>每个清单成员以单行表示，并用短杠 + 空白（ -   ）起始。或使用方括号（ [ ] ），并用逗号 + 空白（ ,   ）分开成员。</li>
<li>每个散列表的成员用冒号 + 空白（ :   ）分开键值和内容。或使用大括号（ {   } ），并用逗号 + 空白（ ,   ）分开。</li>
<li>散列表的键值可以用问号 ( ? ) 起始，用来明确的表示多个词汇组成的键值。</li>
<li>字符串平常并不使用引号，但必要的时候可以用双引号 ( “ ) 或单引号 ( ‘ ) 框住。</li>
<li>使用双引号表示字符串时，可用倒斜线（ \ ）开始的转义字符（这跟 C 语言类似）表示特殊字符。</li>
<li>区块的字符串用缩进和修饰符（非必要）来和其他数据分隔，有新行保留（preserve）（使用符号 | ）或新行折叠（flod）（使用符号 &gt; ）两种方式。</li>
<li>在单一文件中，可用连续三个连字号（—）区分多个文件。</li>
<li>另外，还有选择性的连续三个点号（ … ）用来表示文件结尾。</li>
<li>重复的内容可使从参考标记星号 ( * ) 复制到锚点标记（ &amp; ）。</li>
<li>指定格式可以使用两个惊叹号 ( !! )，后面接上名称。</li>
<li>文件中的单一文件可以使用指导指令，使用方法是百分比符号 ( % )。有两个指导指令在 YAML1.1 版中被定义：</li>
<li>% YAML 指导指令，用来识别文件的 YAML 版本。</li>
<li>% TAG 指导指令，被用在 URI 的前缀标记。这个方法在标记节点的类型时相当有用。</li>
<li>YAML 在使用逗号及冒号时，后面都必须接一个空白字符，所以可以在字符串或数值中自由加入分隔符号（例如：5,280 或 <a href="https://links.jianshu.com/go?to=http://www.wikipedia.org">http://www.wikipedia.org</a>）而不  需要使用引号。</li>
</ul>
<h4 id="2、基本类型："><a href="#2、基本类型：" class="headerlink" title="2、基本类型："></a>2、基本类型：</h4><p>yaml中有以下基本类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串</span><br><span class="line">整型</span><br><span class="line">浮点型</span><br><span class="line">布尔型</span><br><span class="line">null</span><br><span class="line">时间</span><br><span class="line">日期</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-键值关系"><a href="#3-键值关系" class="headerlink" title="3. 键值关系"></a>3. <strong>键值关系</strong></h4><p>(以Java语言为例，其它语言类似)对于键与值主要是看能否表示以下内容。普通的值(数字、字符串、布尔)、日期、对象、数组、集合等。</p>
<h5 id="1-普通值-字面量"><a href="#1-普通值-字面量" class="headerlink" title="1)  普通值(字面量)"></a>1)  普通值(字面量)</h5><ul>
<li><p>k: v：字面量直接写；</p>
</li>
<li><p>字符串默认不用加上单引号或者双引号；</p>
</li>
<li><p>“”: 双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
</li>
<li><p>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi</p>
</li>
<li><p>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name1: zhangsan</span><br><span class="line">name2: &#x27;zhangsan \n lisi&#x27;</span><br><span class="line">name3: &quot;zhangsan \n lisi&quot;</span><br><span class="line">age: 18</span><br><span class="line">flag: true</span><br></pre></td></tr></table></figure>



<h5 id="2-日期"><a href="#2-日期" class="headerlink" title="2) 日期"></a>2) 日期</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date: 2019/01/01</span><br></pre></td></tr></table></figure>



<h5 id="3-清单（数组）"><a href="#3-清单（数组）" class="headerlink" title="3) 清单（数组）"></a>3) 清单（数组）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 最喜爱的电影</span><br><span class="line">- Casablanca</span><br><span class="line">- North by Northwest</span><br><span class="line">- Notorious</span><br></pre></td></tr></table></figure>

<p>行内写法：另外还有一种内置格式（inline format）可以选择用方括号围住，并用逗号 + 空白区隔（类似 JSON 的语法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 购物清单</span><br><span class="line">[milk, pumpkin pie, eggs, juice]</span><br></pre></td></tr></table></figure>



<h5 id="4-散列表"><a href="#4-散列表" class="headerlink" title="4) 散列表"></a>4) 散列表</h5><p>键值和数据由冒号及空白字符分开。区块形式（常使用与 YAML 数据文档中）使用缩进和换行符分隔 key: value 对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 区块形式</span><br><span class="line">   name: John Smith</span><br><span class="line">   age: 33</span><br></pre></td></tr></table></figure>

<p>内置形式（常使用与 YAML 数据流中）在大括号中使用逗号 + 空白字符分隔 key: value 对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 內置形式</span><br><span class="line"> &#123;name: John Smith, age: 33&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-对象-属性和值-、Map-键值对"><a href="#5-对象-属性和值-、Map-键值对" class="headerlink" title="5) 对象(属性和值)、Map(键值对)"></a>5) 对象(属性和值)、Map(键值对)</h5><p>在下一行来写对象的属性和值的关系，注意缩进</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people:</span><br><span class="line">    name: zhangsan</span><br><span class="line">    age: 20</span><br></pre></td></tr></table></figure>

<p>行内写法：另外还有一种内置格式（inline format）可使用大括号（ {   } ），并用逗号 + 空白（ ,   ）分开（类似 JSON 的语法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people: &#123;name: zhangsan,age: 20&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-数组、list、set"><a href="#6-数组、list、set" class="headerlink" title="6) 数组、list、set"></a>6) 数组、list、set</h5><p>用- 值表示数组中的一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets:</span><br><span class="line">    - dog</span><br><span class="line">    - pig</span><br><span class="line">    - cat</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>行内写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets: [dog,pig,cat]</span><br></pre></td></tr></table></figure>



<h5 id="7-数组对象、list对象、set对象"><a href="#7-数组对象、list对象、set对象" class="headerlink" title="7) 数组对象、list对象、set对象"></a>7) 数组对象、list对象、set对象</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peoples:</span><br><span class="line">    - name: zhangsan</span><br><span class="line">      age: 22</span><br><span class="line">    - name: lisi</span><br><span class="line">      age: 20</span><br><span class="line">    - &#123;name: wangwu,age: 18&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-区块的字符"><a href="#8-区块的字符" class="headerlink" title="8) 区块的字符"></a>8) 区块的字符</h5><p>再次强调，字符串不需要包在引号之内。有两种方法书写多行文字（multi-line strings），一种可以保存新行（使用 | 字符），另一种可以折叠新行（使用 &gt; 字符）。</p>
<h6 id="保存新行-Newlines-preserved"><a href="#保存新行-Newlines-preserved" class="headerlink" title="保存新行 (Newlines preserved)"></a>保存新行 (Newlines preserved)</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: |                                     # 译者注：这是一首著名的五行民谣(limerick)</span><br><span class="line">   There once was a man from Darjeeling     # 这里曾有一个人來自大吉岭</span><br><span class="line">   Who got on a bus bound for Ealing        # 他搭上一班往伊灵的公车</span><br><span class="line">       It said on the door                  # 门上这么说的</span><br><span class="line">       &quot;Please don&#x27;t spit on the floor&quot;     # &quot;请勿在地上吐痰&quot;</span><br><span class="line">   So he carefully spat on the ceiling      # 所以他小心翼翼的吐在天花板上</span><br></pre></td></tr></table></figure>

<p>根据设置，前方的引领空白符号（leading white space）必须排成条状，以便和其他数据或是行为（如示例中的缩进）明显区分。</p>
<h6 id="折叠新行-Newlines-folded"><a href="#折叠新行-Newlines-folded" class="headerlink" title="折叠新行 (Newlines folded)"></a>折叠新行 (Newlines folded)</h6><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">data: &gt;</span><br><span class="line">   Wrapped text         <span class="meta"># 摺疊的文字</span></span><br><span class="line">   will be folded       <span class="meta"># 將會被收</span></span><br><span class="line">   <span class="keyword">into</span> a single        <span class="meta"># 進單一一個</span></span><br><span class="line">   paragraph            <span class="meta"># 段落</span></span><br><span class="line">   </span><br><span class="line">   Blank lines denote   <span class="meta"># 空白的行代表</span></span><br><span class="line">   paragraph breaks     <span class="meta"># 段落之間的區隔</span></span><br></pre></td></tr></table></figure>

<p>和保存新行不同的是，换行字符会被转换成空白字符。而引领空白字符则会被自动消去。</p>
<h5 id="9-层次结构化的元素"><a href="#9-层次结构化的元素" class="headerlink" title="9) 层次结构化的元素"></a>9) 层次结构化的元素</h5><p>清单中使用散列表</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">- &#123;name: John Smith, age: <span class="number">33</span>&#125;</span><br><span class="line">- name: Mary Smith</span><br><span class="line">  age: <span class="number">27</span></span><br></pre></td></tr></table></figure>

<h6 id="散列表中使用清单"><a href="#散列表中使用清单" class="headerlink" title="散列表中使用清单"></a>散列表中使用清单</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">men: [John Smith, Bill Jones]</span><br><span class="line">women:</span><br><span class="line">  - Mary Smith</span><br><span class="line">  - Susan Williams</span><br></pre></td></tr></table></figure>



<h3 id="四、YAML-的高级组件"><a href="#四、YAML-的高级组件" class="headerlink" title="四、YAML 的高级组件"></a>四、YAML 的高级组件</h3><p>这部分算是一个后续的讨论，在比较各种数数据列语言时，YAML 最常被提到的特色有两个：关系树和数据形态。</p>
<h4 id="树状结构之间的交互引用"><a href="#树状结构之间的交互引用" class="headerlink" title="树状结构之间的交互引用"></a>树状结构之间的交互引用</h4><h5 id="数据合并和参考"><a href="#数据合并和参考" class="headerlink" title="数据合并和参考"></a>数据合并和参考</h5><p>为了维持文件的简洁，并避免数据输入的错误，YAML 提供了结点参考（*）和散列合并（&lt;&lt;）参考到其他结点标签的锚点标记（&amp;）。参考会将树状结构加入锚点标记的内容，并可以在所有数据结构中运作（可以参考上面 “ship-to” 的示例）合并只有散列表可以使用，可以将键值自锚点标记复制到指定的散列表中。</p>
<p>当数据被 instantiate 合并和参考会被剖析器自动展开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#眼部雷射手術之標準程序</span><br><span class="line">---</span><br><span class="line">- step:  &amp;id001                  # 定義錨點標籤 &amp;id001</span><br><span class="line">    instrument:      Lasik 2000</span><br><span class="line">    pulseEnergy:     5.4</span><br><span class="line">    pulseDuration:   12</span><br><span class="line">    repetition:      1000</span><br><span class="line">    spotSize:        1mm</span><br><span class="line"></span><br><span class="line">- step:</span><br><span class="line">     &lt;&lt;: *id001                  # 合併鍵值：使用在錨點標籤定義的內容</span><br><span class="line">     spotSize:       2mm         # 覆寫&quot;spotSize&quot;鍵值</span><br><span class="line"></span><br><span class="line">- step:</span><br><span class="line">     &lt;&lt;: *id001                  # 合併鍵值：使用在錨點標籤定義的內容</span><br><span class="line">     pulseEnergy:    500.0       # 覆寫鍵值</span><br><span class="line">     alert: &gt;                    # 加入其他鍵值</span><br><span class="line">           warn patient of </span><br><span class="line">           audible pop</span><br></pre></td></tr></table></figure>

<h5 id="数据形态"><a href="#数据形态" class="headerlink" title="数据形态"></a>数据形态</h5><p>由于自动判定数据形态的功能，严格类型（也就是用户有宣告的数据形态）很难在大部分的 YAML 文件中看到。数据类型可以被区分成三大类：原码（core），定义（defined），用户定义（user-defined）。原码可以自动被解析器分析（例如：浮点数，整数，字符串，清单，映射，…）。有一些高级的数据形态──例如比特数据──在 YAML 中有被 “定义”，但不是每一种解析器都有支持。最后，YAML 支持用户自定的区域变量，包括：自定义的类别，结构或基本类型（例如：四倍精度的浮点数）。</p>
<h5 id="强制转型"><a href="#强制转型" class="headerlink" title="强制转型"></a>强制转型</h5><p>YAML 的自动判定数据形态是哪一种实体。但有时用户会想要将数据强制转型成自定的某种类型。最常见的状况是字符串，有时候可能看起来像数字或布尔值，这种时候可以使用双引号，或是使用严格类型标签。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">a: <span class="number">123</span>                     # 整數</span><br><span class="line">b: <span class="string">&quot;123&quot;</span>                   # 字串（使用雙括號）</span><br><span class="line">c: <span class="number">123.0</span>                   # 浮點數</span><br><span class="line">d: !!<span class="keyword">float</span> <span class="number">123</span>             # 浮點數，使用!!表達的嚴格型態</span><br><span class="line">e: !!str <span class="number">123</span>               # 字串，使用嚴格型態</span><br><span class="line">f: !!str Yes               # 字串，使用嚴格型態</span><br><span class="line">g: Yes                     # 布林值<span class="string">&quot;真&quot;</span></span><br><span class="line">h: Yes we have No bananas  # 字串（包含<span class="string">&quot;Yes&quot;</span>和<span class="string">&quot;No&quot;</span>）</span><br></pre></td></tr></table></figure>



<h5 id="其他特殊数据形态"><a href="#其他特殊数据形态" class="headerlink" title="其他特殊数据形态"></a>其他特殊数据形态</h5><p>除了一般的数据形态之外，用户也可以使用一些较为高级的类型，但不保证可被每种解析器分析。使用时和强制转型类似，要在形态名称之前加上两个惊叹号（!!）。有几种重要的形态在本篇没有讨论，包括集合（sets），有序映照（ordered maps），时间戳记（timestamps）以及十六进制数据（hexadecimal）。</p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将文件夹固定到Windows任务栏</title>
    <url>/2021/06/24/%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E4%BB%B6%E5%A4%B9%E5%9B%BA%E5%AE%9A%E5%88%B0Windows%E4%BB%BB%E5%8A%A1%E6%A0%8F/</url>
    <content><![CDATA[<p>经常频繁的用到某个文件夹，从盘符点进入麻烦而且又耽搁时间，我们直接把频繁用到的文件夹固定到桌面任务栏，就很方便的来进行我们的操作。</p>
<span id="more"></span>

<hr>
<p>Windows不允许您将文件夹直接固定到任务栏。 不过，有一个简单的解决方法。 您要做的就是为文件夹创建一个新的快捷方式，然后将该快捷方式固定在任务栏上。</p>
<p>具体步骤如下：</p>
<ol>
<li><p>右键单击桌面上或文件浏览器中的任意位置，然后从上下文菜单中选择“新建&gt;快捷方式”。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624153145.png" alt="image-20210624153138112"></p>
</li>
</ol>
<ol start="2">
<li><p>“创建快捷方式”向导的第一页上，单击“浏览”按钮以找到要固定的文件夹。 但是，选择文件夹后，请不要单击“下一步”。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624153713.png" alt="image-20210624153713114"></p>
</li>
<li><p>现在添加“ Explorer”(不带引号)，然后在您选择的文件夹路径之前添加一个空格。 之后，继续并单击“下一步”按钮。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624153835.png" alt="image-20210624153835259"></p>
</li>
</ol>
<ol start="4">
<li><p>输入快捷方式的名称，然后单击“完成”以在您选择的位置创建快捷方式。</p>
</li>
<li><p>更改快捷方式的图标。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624154248.png" alt="image-20210624154248814"></p>
</li>
</ol>
<ol start="6">
<li><p>把图标拖到任务栏将其固定，删除桌面的快捷方式任务栏的文件夹快捷方式就建立好了。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624155528.png" alt="image-20210624155528477"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>windows</category>
        <category>快捷方式</category>
      </categories>
      <tags>
        <tag>任务栏</tag>
        <tag>文件夹</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机编码</title>
    <url>/2021/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>经常遇到Unicode和UTF-8，具体是什么意思，他们之间有什么区别呢？本编文章简要的解密计算机编码问题</p>
<span id="more"></span>

<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><ul>
<li>最早，127个字符被编码到计算机里，也就是大小写英文字母,数字及一些符号，这个编码表被称为ASCII编码</li>
</ul>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>全世界有上百种语言，Unicode把所有语言都统一到一套编码里，这样就不会有乱码问题了。</p>
<h2 id="ASCII编码和Unicode编码的区别："><a href="#ASCII编码和Unicode编码的区别：" class="headerlink" title="ASCII编码和Unicode编码的区别："></a>ASCII编码和Unicode编码的区别：</h2><ul>
<li>ASCII编码是1个字节</li>
<li>Unicode编码通常是两个字节。</li>
<li>字母A用ASCII编码是十进制的65，二进制的01000001。</li>
<li>如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此A的Unicode编码是00000000 01000001。</li>
<li>如果统一成Unicode编码，但是用Unicode编码比ASCII编码多一倍存储空间，在存储和传输上十分不划算。</li>
</ul>
<h1 id="本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。"><a href="#本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。" class="headerlink" title="本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。"></a>本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。</h1><ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1～6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节</li>
<li>计算机系统通用的字符编码工作方式：在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或需要传输时，可以转换为UTF-8编码。</li>
</ul>
]]></content>
      <categories>
        <category>小知识</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
      </tags>
  </entry>
</search>
