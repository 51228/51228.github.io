<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LATEX数学公式学习之一（规则）</title>
    <url>/2021/11/05/LATEX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80%EF%BC%88%E8%A7%84%E5%88%99%EF%BC%89/</url>
    <content><![CDATA[<p>本章学习LATEX的使用规则和一些注意的事项</p>
<span id="more"></span>

<h3 id="一-命令"><a href="#一-命令" class="headerlink" title="一. 命令"></a>一. 命令</h3><h4 id="一）、命令的分类"><a href="#一）、命令的分类" class="headerlink" title="一）、命令的分类"></a>一）、命令的分类</h4><h5 id="排版命令分为两种，一种是控制词，另一种是控制符。"><a href="#排版命令分为两种，一种是控制词，另一种是控制符。" class="headerlink" title="排版命令分为两种，一种是控制词，另一种是控制符。"></a>排版命令分为两种，一种是控制词，另一种是控制符。</h5><ol>
<li>控制词：控制词由反斜杠和紧跟着其后的一个或多个英文字母组成<ul>
<li>例如：\sin</li>
</ul>
</li>
<li>控制符：控制符由反斜杠和紧跟着其后的符号（不是英文字母）组成<ul>
<li>例如：\： ;</li>
</ul>
</li>
</ol>
<h5 id="根据命令的复杂程度，命令又可以分为一般性命令和带参数命令。"><a href="#根据命令的复杂程度，命令又可以分为一般性命令和带参数命令。" class="headerlink" title="根据命令的复杂程度，命令又可以分为一般性命令和带参数命令。"></a>根据命令的复杂程度，命令又可以分为一般性命令和带参数命令。</h5><ol>
<li>一般性命令：反斜杠后面紧跟一个字符且不带参数</li>
<li>带参数命令：参数选项分为可选参数和必选参数<ul>
<li>可选参数是可以省略的参数，放在方括号“[]”中</li>
<li>必选参数不可省略，放在花括号“{}”中</li>
<li>参数之间用逗号隔开“,”</li>
</ul>
</li>
</ol>
<h4 id="二）、命令的输入"><a href="#二）、命令的输入" class="headerlink" title="二）、命令的输入"></a>二）、命令的输入</h4><p>在输入命令时，命令必须紧跟反斜杠，输入完成后最好敲一个空格</p>
<h3 id="二-数学模式"><a href="#二-数学模式" class="headerlink" title="二. 数学模式"></a>二. 数学模式</h3><h4 id="一）、基本规则"><a href="#一）、基本规则" class="headerlink" title="一）、基本规则"></a>一）、基本规则</h4><ol>
<li><p>行内模式界定标记：<code>$……$</code>或<code>\(…………\)</code></p>
</li>
<li><p>行间模式界定标记：<code>$$……$$</code>或<code>\[…………\]</code></p>
</li>
</ol>
<h4 id="二）、系统处理数学模式字符遵循的规则"><a href="#二）、系统处理数学模式字符遵循的规则" class="headerlink" title="二）、系统处理数学模式字符遵循的规则"></a>二）、系统处理数学模式字符遵循的规则</h4><ol>
<li>• 表示变量的字母排版成斜体，如果想要某些字母不排成斜体，则用专门的命令输入。</li>
<li>• 函数名有专用的命令输入，输出为正体。</li>
<li>• 空格键输入的空格被忽略，想要输出一定的间距，则用空白命令输入。</li>
<li>• 数学模式内不能直接输入文本，输入文本要用专门的文本命令。</li>
</ol>
<h4 id="三）、排版数学公式的几个刚性要求"><a href="#三）、排版数学公式的几个刚性要求" class="headerlink" title="三）、排版数学公式的几个刚性要求"></a>三）、排版数学公式的几个刚性要求</h4><ol>
<li><p>• 单个的字母表示向量时，顶上无箭头，字母必须使用粗斜体。可在导言区调用宏包bm，使用命令\bm{字母}实现，如输入：$\bm{a}$，输出：a。</p>
</li>
<li><p>• 对于常数e，i及微分算子d，在数学式中都要采用正体，使用命令\mathrm{拉丁字母}输入，以区别斜体的变量。对于圆周率π，由于其是希腊字母不能使用命令\mathrm生成，而须用专门的命令。在不同的宏包中圆周率有不同的命令和输出样式。</p>
</li>
<li><p>• 数值带单位时，数值和单位之间要有较小的空白，使用命令\，生成空白，并且单位必须用正体。如0.618kg是这样输入的：$0.618,\mathrm{kg}$（也可以不用数学模式直接输入：0.618,kg得到同样的输出）。</p>
</li>
</ol>
<h4 id="四）、数学模式中的四种字号控制命令"><a href="#四）、数学模式中的四种字号控制命令" class="headerlink" title="四）、数学模式中的四种字号控制命令"></a>四）、数学模式中的四种字号控制命令</h4><ol>
<li><code>\displaystyle</code>：行间公式尺寸</li>
<li><code>\textstyle：行内公式尺寸</code></li>
<li><code>\scriptstyle：一级角标尺寸</code></li>
<li><code>\scriptscriptstyle：二级角标尺寸</code></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>数学公式学习之二（常用符号）</title>
    <url>/2021/11/05/LATEX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%8C%EF%BC%88%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%EF%BC%89/</url>
    <content><![CDATA[<p>本节学习内容是数学公式常用符号的总结。</p>
<span id="more"></span>

<h5 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h5><p><a href="#1">操作符</a></p>
<p><a href="#2">关系符及否定形式</a></p>
<p><a href="#3">数学普通符号</a></p>
<p><a href="#4">小写希腊字符</a></p>
<p><a href="#5">大写希腊字符</a></p>
<p><a href="#6">数学模式重音符</a></p>
<p><a href="#7">空格</a></p>
<p><a href="#8">箭头</a></p>
<p><a href="#9">常见的数学字母字体包</a></p>
<p><a href="#10">省略号</a></p>
<hr>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a><span id="1">操作符</span></h3><p>$$<br>\begin{align*}<br>&amp; \backslash pm ：&amp;\pm \qquad<br>&amp; \backslash mp ：&amp;\mp \qquad<br>&amp; \backslash times ：&amp;\times \qquad     \<br>&amp; \backslash div ：&amp;\div \qquad<br>&amp; \backslash ast ：&amp;\ast \qquad<br>&amp; \backslash star ：&amp;\star \qquad     \<br>&amp; \backslash dagger ：&amp;\dagger  \qquad<br>&amp; \backslash ddagger ：&amp;\ddagger  \qquad<br>&amp; \backslash amalg ：&amp;\amalg  \qquad     \<br>&amp; \backslash cap ：&amp;\cap  \qquad<br>&amp; \backslash cup ：&amp;\cup  \qquad<br>&amp; \backslash uplus ：&amp;\uplus  \qquad     \<br>&amp; \backslash sqcap ：&amp;\sqcap  \qquad<br>&amp; \backslash sqcup ：&amp;\sqcup \qquad<br>&amp; \backslash  vee：&amp;\vee  \qquad     \<br>&amp; \backslash wedge ：&amp;\wedge  \qquad<br>&amp; \backslash oplus ：&amp;\oplus  \qquad<br>&amp; \backslash ominus ：&amp;\ominus  \qquad     \<br>&amp; \backslash otimes ：&amp;\otimes  \qquad<br>&amp; \backslash bullet ：&amp;\bullet  \qquad<br>&amp; \backslash diamond ：&amp;\diamond  \qquad     \<br>&amp; \backslash Diamond ：&amp;\Diamond  \qquad<br>&amp; \backslash lhd ：&amp;\lhd  \qquad<br>&amp; \backslash rhd ：&amp;\rhd  \qquad     \<br>&amp; \backslash unlhd ：&amp;\unlhd  \qquad<br>&amp; \backslash unrhd ：&amp;\unrhd  \qquad<br>&amp; \backslash oslash ：&amp;\oslash  \qquad     \<br>&amp; \backslash odot ：&amp;\odot  \qquad<br>&amp; \backslash triangleleft ：&amp;\triangleleft  \qquad<br>&amp; \backslash triangleright ：&amp;\triangleright  \qquad    \<br>&amp; \backslash bigtriangleup ：&amp;\bigtriangleup  \qquad<br>&amp; \backslash triangledown ：&amp;\triangledown  \qquad<br>&amp; \backslash Box ：&amp;\Box  \qquad     \<br>&amp; \backslash setminus ：&amp;\setminus  \qquad<br>&amp; \backslash bigcup ：&amp;\bigcup  \qquad<br>&amp; \backslash bigcap ：&amp;\bigcap  \qquad<br>\end{align*}<br>$$</p>
<h3 id="关系符及否定形式"><a href="#关系符及否定形式" class="headerlink" title="关系符及否定形式"></a><span id="2">关系符及否定形式</span></h3><p>$$<br>\begin{align*}<br>&amp; \backslash &#x3D; ：&amp;&#x3D;  \qquad<br>&amp; \backslash ne ：&amp;\ne  \qquad<br>&amp; \backslash ： ：&amp;:  \qquad          \<br>&amp; \backslash &gt; ：&amp;&gt;  \qquad<br>&amp; \backslash nless ：&amp;\nless  \qquad<br>&amp; \backslash  &gt;：&amp;&gt;  \qquad         \<br>&amp; \backslash  ngtr：&amp;\ngtr  \qquad<br>&amp; \backslash  le：&amp;\le  \qquad<br>&amp; \backslash  nleq：&amp;\nleq  \qquad         \<br>&amp; \backslash  ge：&amp;\ge  \qquad<br>&amp; \backslash  ngeq：&amp;\ngeq  \qquad<br>&amp; \backslash  in：&amp;\in  \qquad           \<br>&amp; \backslash  notin：&amp;\notin  \qquad<br>&amp; \backslash  ni：&amp;\ni  \qquad<br>&amp; \backslash  ll：&amp;\ll  \qquad         \<br>&amp; \backslash  gg：&amp;\gg  \qquad<br>&amp; \backslash  prec：&amp;\prec  \qquad<br>&amp; \backslash  nprec：&amp;\nprec  \qquad         \<br>&amp; \backslash  succ：&amp;\succ  \qquad<br>&amp; \backslash nsucc：&amp;\nsucc  \qquad<br>&amp; \backslash  preceq：&amp;\preceq  \qquad         \<br>&amp; \backslash  npreceq：&amp;\npreceq  \qquad<br>&amp; \backslash  precneqq：&amp;\precneqq  \qquad<br>&amp; \backslash  succeq：&amp;\succeq  \qquad           \<br>&amp; \backslash  nsucceq：&amp;\nsucceq  \qquad<br>&amp; \backslash  succneqq：&amp;\succneqq  \qquad<br>&amp; \backslash  sim：&amp;\sim  \qquad          \<br>&amp; \backslash  nsim：&amp;\nsim  \qquad<br>&amp; \backslash  approx：&amp;\approx  \qquad<br>&amp; \backslash  simeq：&amp;\simeq  \qquad         \<br>&amp; \backslash  cong：&amp;\cong  \qquad<br>&amp; \backslash  ncong：&amp;\ncong  \qquad<br>&amp; \backslash  equiv：&amp;\equiv  \qquad         \<br>&amp; \backslash  doteq：&amp;\doteq  \qquad<br>&amp; \backslash  subset：&amp;\subset  \qquad<br>&amp; \backslash  supset：&amp;\supset  \qquad           \<br>&amp; \backslash  subseteq：&amp;\subseteq  \qquad<br>&amp; \backslash  supseteq：&amp;\supseteq  \qquad<br>&amp; \backslash  nsubseteq：&amp;\nsubseteq  \qquad         \<br>&amp; \backslash  nsupseteq：&amp;\nsupseteq  \qquad<br>&amp; \backslash  varsubsetneq：&amp;\varsubsetneq  \qquad<br>&amp; \backslash  varsupsetneq：&amp;\varsubsetneq  \qquad         \<br>&amp; \backslash  subsetneq：&amp;\subsetneq  \qquad<br>&amp; \backslash  supsetneq：&amp;\supsetneq  \qquad<br>&amp; \backslash  smile：&amp;\smile  \qquad         \<br>&amp; \backslash  frown：&amp;\frown  \qquad<br>&amp; \backslash  perp：&amp;\perp  \qquad<br>&amp; \backslash  models：&amp;\models  \qquad           \<br>&amp; \backslash  mid：&amp;\mid  \qquad<br>&amp; \backslash  nmid：&amp;\nmid  \qquad<br>&amp; \backslash  parallel：&amp;\parallel  \qquad          \<br>&amp; \backslash  nparallel：&amp;\nparallel  \qquad<br>&amp; \backslash  vdash：&amp;\vdash  \qquad<br>&amp; \backslash  nvdash：&amp;\nvdash  \qquad         \<br>&amp; \backslash  dashv：&amp;\dashv  \qquad<br>&amp; \backslash  propto：&amp;\propto  \qquad<br>&amp; \backslash  asymp：&amp;\asymp  \qquad         \<br>&amp; \backslash  bowtie：&amp;\bowtie  \qquad         </p>
<p>\end{align*}<br>$$</p>
<h3 id="数学普通符号"><a href="#数学普通符号" class="headerlink" title="数学普通符号"></a><span id="3">数学普通符号</span></h3><p>$$<br>\begin{alignat*}{3}<br>\backslash partial ：&amp;\partial  \hspace{30mm} &amp; \backslash infty ：&amp;\infty \hspace{30mm} &amp;\backslash surd ：\surd\<br>\backslash triangle ： &amp;\triangle     &amp;\backslash top ：&amp;\top &amp;\backslash nabla：&amp;\nabla \<br>\backslash  forall： &amp;\forall &amp;\backslash  ell：&amp;\ell  &amp;\backslash  mho：&amp;\mho \<br>\backslash  varnothing： &amp;\varnothing  &amp;\backslash  circledS：&amp;\circledS  &amp;\backslash  angle：&amp;\angle \<br>\backslash  star： &amp;\star &amp;\backslash bigstar ：&amp;\bigstar  &amp;\backslash eth ：&amp;\eth \<br>\backslash  clubsuit： &amp;\clubsuit &amp;\backslash spadesuit ：&amp;\spadesuit  &amp;\backslash heartsuit ：&amp;\heartsuit \<br>\backslash  diamondsuit： &amp;\diamondsuit &amp;\backslash sphericalangle ：&amp;\sphericalangle  &amp;\backslash measuredangle ：&amp;\measuredangle \<br>\backslash  circledR： &amp;\circledR&amp;\backslash circ：&amp;\circ   &amp;\backslash bigcirc：&amp;\bigcirc\\<br>\end{alignat*}<br>$$</p>
<h3 id="小写希腊字符："><a href="#小写希腊字符：" class="headerlink" title="小写希腊字符："></a><span id="4">小写希腊字符：</span></h3><p>$$<br>\begin{align*}<br>&amp; \backslash alpha ：&amp;\alpha \qquad  \qquad \qquad  \qquad<br>&amp; \backslash beta ：&amp;\beta \qquad  \qquad \qquad  \qquad<br>&amp; \backslash chi ：&amp;\chi \<br>&amp; \backslash delta ：&amp;\delta  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash epsilon：&amp;\epsilon   \qquad  \qquad \qquad  \qquad<br>&amp; \backslash eta：&amp;\eta \<br>&amp; \backslash gamma：&amp;\gamma  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash iota：&amp;\iota  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash lambda：&amp;\lambda \<br>&amp; \backslash nu：&amp;\nu  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash mu：&amp;\mu  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash o &amp;o \<br>&amp; \backslash omega：&amp;\omega  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash phi：&amp;\phi  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash pi：&amp;\pi \<br>&amp; \backslash psi：&amp;\psi  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash rho：&amp;\rho  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash sigma：&amp;\sigma \<br>&amp; \backslash tau：&amp;\tau   \qquad  \qquad \qquad  \qquad<br>&amp; \backslash theta：&amp;\theta   \qquad  \qquad \qquad  \qquad<br>&amp; \backslash nabla： &amp;\nabla \<br>&amp; \backslash partial：&amp;\partial  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash upsilon：&amp;\upsilon  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash xi：&amp;\xi \<br>&amp; \backslash zeta：&amp;\zeta  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash digamma：&amp;\digamma  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash varepsilon：&amp;\varepsilon \<br>&amp; \backslash varkappa：&amp;\varkappa  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash varphi：&amp;\varphi  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash varpi：&amp;\varpi \<br>&amp; \backslash varrho：&amp;\varrho  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash varsigma：&amp;\varsigma  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash vartheta：&amp;\vartheta \<br>&amp; \backslash aleph：&amp;\aleph  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash beth：&amp;\beth  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash daleth：&amp;\daleth \<br>&amp; \backslash gimel：&amp;\gimel \qquad  \qquad \qquad  \qquad<br>\end{align*}<br>$$</p>
<h3 id="大写希腊字符："><a href="#大写希腊字符：" class="headerlink" title="大写希腊字符："></a><span id="5">大写希腊字符：</span></h3><p>$$<br>\begin{align*}<br>&amp; \backslash  Delta：&amp;\Delta  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash  Gamma：&amp;\Gamma  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash  Lambda：&amp;\Lambda \<br>&amp; \backslash  Omega：&amp;\Omega  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash  Phi：&amp;\Phi  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash  Pi：&amp;\Pi \<br>&amp; \backslash  Psi：&amp;\Psi  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash  Sigma：&amp;\Sigma  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash  Theta：&amp;\Theta \<br>&amp; \backslash  Upsilon：&amp;\Upsilon  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash  Xi：&amp;\Xi  \qquad  \qquad \qquad  \qquad\<br>\end{align*}<br>$$</p>
<h3 id="数学模式重音符"><a href="#数学模式重音符" class="headerlink" title="数学模式重音符:"></a><span id="6">数学模式重音符:</span></h3><p>$$<br>\begin{align*}<br>&amp; \backslash hat{a}：&amp;\hat{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash check{a}：&amp;\check{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash tilde{a}：&amp;\tilde{a}\<br>&amp; \backslash acute{a}：&amp;\acute{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash grave{a}：&amp;\grave{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash dot{a}：&amp;\dot{a}\<br>&amp; \backslash ddot{a}：&amp;\ddot{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash breve{a}：&amp;\breve{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash bar{a}：&amp;\bar{a}\<br>&amp; \backslash vec{a}：&amp;\vec{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash widehat{a}：&amp;\widehat{a}  \qquad  \qquad \qquad  \qquad<br>&amp; \backslash widetilde{a}：&amp;\widetilde{a}\<br>\end{align*}<br>$$</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a><span id="7">空格</span></h3><p>$$<br>\begin{align*}<br>&amp; 两个quad空格：\qquad\qquad &amp;a \backslash qquad \ b \qquad \qquad  \qquad &amp;a\qquad b \qquad \qquad&amp;两个m的宽度 \<br>&amp; quad空格：\qquad\qquad &amp;a \backslash quad \ b  \qquad\qquad \qquad &amp;a\quad b \qquad   \qquad&amp;一个m的宽度 \<br>&amp; 大空格：\qquad\qquad &amp;a\backslash \ b  \qquad \qquad \qquad &amp;a\ b \qquad  \qquad&amp;1&#x2F;3m宽度 \<br>&amp; 中等空格：\qquad\qquad &amp;a\backslash ; b  \qquad \qquad \qquad &amp;a; b \qquad  \qquad&amp;2&#x2F;7m宽度 \<br>&amp; 小空格：\qquad\qquad &amp;a\backslash ,b      \qquad \qquad \qquad &amp;a,b \qquad   \qquad&amp;1&#x2F;6m宽度 \<br>&amp; 没有空格：\qquad\qquad &amp;ab  \qquad \qquad \qquad &amp;ab \qquad \qquad \qquad&amp; 无 \<br>&amp; 紧贴：\qquad\qquad &amp;a\backslash !b   \qquad \qquad \qquad &amp;a!b \qquad   \qquad&amp;缩进1&#x2F;6m宽度<br>\end{align*}\qquad<br>$$</p>
<h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a><span id="8">箭头</span></h3><p>$$<br>\begin{alignat*}{3}<br>\backslash leftarrow：&amp;  \leftarrow \hspace{15mm} &amp;\backslash gets ：&amp;  \gets  \hspace{15mm}&amp; \backslash rightarrow ：&amp; \rightarrow\<br>\backslash to ：&amp; \to  &amp; \backslash uparrow ：&amp; \uparrow  &amp;\backslash downarrow ：&amp; \downarrow\<br>\backslash leftrightarrow ：&amp; \leftrightarrow  &amp; \backslash leftrightarrows ：&amp; \leftrightarrows  &amp;\backslash leftarrowtail ：&amp; \leftarrowtail\<br>\backslash twoheadleftarrow ：&amp; \twoheadleftarrow  &amp;\backslash Leftarrow ：&amp; \Leftarrow  &amp;\backslash Rightarrow ：&amp; \Rightarrow\<br>\backslash Uparrow ：&amp; \Uparrow  &amp;\backslash Downarrow ：&amp; \Downarrow  &amp;\backslash implies ：&amp; \implies\<br>\backslash iff：&amp;\iff  &amp;\backslash swarrow ：&amp; \swarrow  &amp;\backslash searrow ：&amp; \searrow\<br>\backslash nearrow ：&amp; \nearrow  &amp;\backslash nwarrow ：&amp; \nwarrow  &amp;\backslash leftharpoondown：&amp;  \leftharpoondown\<br>\backslash longleftarrow ：&amp; \longleftarrow  &amp;\backslash longrightarrow ：&amp; \longrightarrow  \qquad  \qquad \qquad&amp;\backslash longleftrightarrow : &amp; \longleftrightarrow  \<br>\backslash Longleftarrow ：&amp; \Longleftarrow  &amp;\backslash Longrightarrow ：&amp; \Longrightarrow  \qquad  \qquad \qquad&amp;\backslash Longleftrightarrow: &amp; \Longleftrightarrow\<br>\backslash circlearrowleft ：&amp; \circlearrowleft  &amp;\backslash circlearrowright ：&amp; \circlearrowright  &amp;\backslash upharpoonleft ：&amp; \upharpoonleft\<br>\backslash  upharpoonleright ：&amp; \upharpoonright  &amp;\backslash  leftharpoonup：&amp; \leftharpoonup  &amp;\backslash  leftharpoondown：&amp; \leftharpoonup \<br>\backslash  rightharpoonup：&amp; \leftharpoonup  &amp; \backslash  rightharpoondown：&amp;\rightharpoondown  &amp; \backslash  rightleftharpoons：&amp; \rightleftharpoons \<br>\backslash mapsto ：&amp; \mapsto  &amp;\backslash longmapsto ：&amp; \longmapsto  &amp;\backslash hookleftarrow ：&amp; \hookleftarrow \<br> \backslash  hookrightarrow：&amp; \hookrightarrow   \<br>\end{alignat*}<br>$$</p>
<h3 id="常见的数学字母字体"><a href="#常见的数学字母字体" class="headerlink" title="常见的数学字母字体"></a><span id="9">常见的数学字母字体</span></h3><p>$$<br>\begin{align*}<br>&amp; \backslash bold{M}：&amp;\bold{M}\qquad  \qquad<br>&amp; \backslash mathsbb{M}：&amp;\mathbb{M}\qquad  \qquad<br>&amp; \backslash mathscr{M}{M}：&amp;\mathscr{M}  \<br>&amp; \backslash mathcal{M}：&amp;\mathcal{M}\qquad  \qquad<br>&amp; \backslash mathfrak{M}：&amp;\mathfrak{M}\qquad  \qquad<br>&amp; \backslash mathrm{M}：&amp;\mathrm{M} \<br>&amp; \backslash mathbf{M}：&amp;\mathbf{M}\qquad  \qquad<br>&amp; \backslash mathsf{M}：&amp;\mathsf{M}\qquad  \qquad<br>&amp; \backslash mathtt{M}：&amp;\mathtt{M} \<br>\end{align*}<br>$$</p>
<h3 id="特殊符号的输入"><a href="#特殊符号的输入" class="headerlink" title="特殊符号的输入"></a><a id="10">特殊符号的输入</a></h3><ul>
<li><p>特殊字符：</p>
<ul>
<li>\verb “特殊字符”</li>
<li>大部分字符前面加反斜杠：\特殊字符</li>
</ul>
</li>
</ul>
<p>$$<br>\begin{align*}<br>&amp; \backslash %：&amp;%  \qquad  \qquad<br>&amp; \backslash  backslash：&amp;\backslash   \qquad  \qquad<br>&amp; \backslash  \verb “$”：&amp;$   \qquad  \qquad\<br>&amp; \backslash  \verb “#”：&amp;#   \qquad  \qquad<br>&amp; \backslash  \verb “{“：&amp;{   \qquad  \qquad<br>&amp; \backslash  \verb “}”：&amp;}   \qquad  \qquad\<br>&amp; \backslash  _：&amp;_   \qquad  \qquad<br>&amp; \backslash  &amp;：&amp;\verb “&amp;”   \qquad  \qquad\</p>
<p>\end{align*}<br>$$</p>
<h3 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a><a id="10">省略号</a></h3><p>$$<br>\begin{alignat*}{3}<br>\backslash dots: &amp; \dots \hspace{20mm} &amp;\backslash ldot : &amp; \ldots \hspace{20mm} &amp; \backslash ddots: &amp;\ddots \<br> \backslash cdots: &amp; \cdots  &amp; \backslash vdots: &amp; \vdots  &amp; \backslash iddots: &amp; \iddots<br>\end{alignat*}<br>$$</p>
]]></content>
      <categories>
        <category>LATEX</category>
        <category>常用符号</category>
      </categories>
      <tags>
        <tag>LATEX</tag>
        <tag>小写希腊字符</tag>
        <tag>大写希腊字符</tag>
        <tag>重音符</tag>
        <tag>空格</tag>
        <tag>关系符</tag>
        <tag>操作符</tag>
        <tag>箭头</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统截图工具Flameshot安装</title>
    <url>/2021/06/21/Ubuntu%E7%B3%BB%E7%BB%9F%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7Flameshot%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<h4 id="习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（sudo-apt-install-flameshot）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。"><a href="#习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（sudo-apt-install-flameshot）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。" class="headerlink" title="习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（sudo apt install flameshot）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。"></a>习惯了用微信的截图工具，在Ubuntu系统下的截图工具怎么都不习惯，不是功能太过简单，就是没有文字标注。网上介绍的Shutter功能不足，GIMP太过复杂，Ubuntu自身带的截图工具功能也太过简陋。终于找到了flameshot，但flameshot的普通安装（<code>sudo apt install flameshot</code>）没有标注文字等一些功能。本文介绍flameshot全部功能的安装。</h4><span id="more"></span>
</blockquote>
<p>本文参考链接：<a href="https://blog.csdn.net/xiaoqiangclub/article/details/105516383">https://blog.csdn.net/xiaoqiangclub/article/details/105516383</a></p>
<p>先上两张图：</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621215841178.png" alt="image-20210621215841178"></p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621215934165.png" alt="image-20210621215934165"></p>
<h4 id="以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。"><a href="#以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。" class="headerlink" title="以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。"></a>以上2张图可以看出全功能版本的flameshot的功能比较丰富：enter可以全屏截图，鼠标右键可以选择画笔的颜色，鼠标滚轮可以调节画笔的粗细，空格键可以调出工具栏。文字标注，添加数字递增圆圈等功能还是比较出彩的。</h4><h2 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h2><h4 id="一、安装git，为后面克隆flameshot做准备"><a href="#一、安装git，为后面克隆flameshot做准备" class="headerlink" title="一、安装git，为后面克隆flameshot做准备"></a>一、安装git，为后面克隆flameshot做准备</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git </span><br></pre></td></tr></table></figure>



<h4 id="二、克隆项目到本地，我克隆到-x2F-home-x2F-sky-x2F-SoftWare-x2F-目录下。"><a href="#二、克隆项目到本地，我克隆到-x2F-home-x2F-sky-x2F-SoftWare-x2F-目录下。" class="headerlink" title="二、克隆项目到本地，我克隆到&#x2F;home&#x2F;sky&#x2F;SoftWare&#x2F;目录下。"></a>二、克隆项目到本地，我克隆到&#x2F;home&#x2F;sky&#x2F;SoftWare&#x2F;目录下。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo git clone https://github.com/lupoDharkael/flameshot.git</span><br></pre></td></tr></table></figure>



<h4 id="三、接下来是根据-github官方文档-的提示安装一些依赖库"><a href="#三、接下来是根据-github官方文档-的提示安装一些依赖库" class="headerlink" title="三、接下来是根据 github官方文档 的提示安装一些依赖库"></a>三、接下来是根据 <code>github官方文档</code> 的提示安装一些依赖库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Compile-time</span><br><span class="line">apt install g++ build-essential qt5-default qt5-qmake qttools5-dev-tools</span><br><span class="line"></span><br><span class="line"># Run-time</span><br><span class="line">apt install libqt5dbus5 libqt5network5 libqt5core5a libqt5widgets5 libqt5gui5 libqt5svg5-dev</span><br><span class="line"></span><br><span class="line"># Optional</span><br><span class="line">apt install git openssl ca-certificates</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621222006062.png" alt="image-20210621222006062"></p>
<h4 id="四、在克隆的目录（-x2F-home-x2F-sky-x2F-SoftWare-x2F-flameshot-x2F-）下进行编译："><a href="#四、在克隆的目录（-x2F-home-x2F-sky-x2F-SoftWare-x2F-flameshot-x2F-）下进行编译：" class="headerlink" title="四、在克隆的目录（&#x2F;home&#x2F;sky&#x2F;SoftWare&#x2F;flameshot&#x2F;）下进行编译："></a>四、在克隆的目录（&#x2F;home&#x2F;sky&#x2F;SoftWare&#x2F;flameshot&#x2F;）下进行编译：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>在这步有如果你用<code>sudo apt install cmake</code> 安装cmake，可能会遇到cmake版本过低的问题，在  <a href="https://cmake.org/files/">https://cmake.org/files/</a>   网站下载最新版本安装即可。</p>
<h4 id="五、编译完成之后执行命令sudo-make-install，安装完成！"><a href="#五、编译完成之后执行命令sudo-make-install，安装完成！" class="headerlink" title="五、编译完成之后执行命令sudo make install，安装完成！"></a>五、编译完成之后执行命令<code>sudo make install</code>，安装完成！</h4><h4 id="六、使用命令which-flameshot可以得到flameshot的位置"><a href="#六、使用命令which-flameshot可以得到flameshot的位置" class="headerlink" title="六、使用命令which flameshot可以得到flameshot的位置"></a>六、使用命令<code>which flameshot</code>可以得到flameshot的位置</h4><h4 id="七、在设置中添加自定义快捷键"><a href="#七、在设置中添加自定义快捷键" class="headerlink" title="七、在设置中添加自定义快捷键"></a>七、在设置中添加自定义快捷键</h4><p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210621223410545.png" alt="image-20210621223410545"></p>
<h4 id="八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。"><a href="#八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。" class="headerlink" title="八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。"></a>八、现在你可以通过快捷键或者通过命令来启动flameshot，当然命令可以加入环境变量。</h4><h3 id="到此，你就有一个完整版的flameshot使用了。"><a href="#到此，你就有一个完整版的flameshot使用了。" class="headerlink" title="到此，你就有一个完整版的flameshot使用了。"></a>到此，你就有一个完整版的flameshot使用了。</h3>]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>flameshot</tag>
        <tag>ubuntu</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title>git diff</title>
    <url>/2021/06/22/git-diff/</url>
    <content><![CDATA[<p>本篇文章介绍了地方法比较的说明，git diff常用参数，git diff里程碑比较和扩展用法。</p>
<span id="more"></span>

<h3 id="diff比较说明"><a href="#diff比较说明" class="headerlink" title="diff比较说明"></a>diff比较说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 --- hello       2020-09-21 17:45:33.551610940 +0800  </span><br><span class="line">2 +++ world       2020-09-21 17:44:46.343610465 +0800  </span><br><span class="line">3 @@ -1，4 +1，4 @@  </span><br><span class="line">4 -应该杜绝文章中的错别子。  </span><br><span class="line">5 +应该杜绝文章中的错别字。  </span><br><span class="line">6    </span><br><span class="line">7  但是无论使用</span><br><span class="line">8  * 全拼，双拼  </span><br><span class="line">9 @@ -6，6 +6，7 @@ </span><br><span class="line">10   </span><br><span class="line">11  是人就有可能犯错，软件更是如此。 </span><br><span class="line">12   </span><br><span class="line">13 -犯了错，就要扣工资！ </span><br><span class="line">14 - </span><br><span class="line">15  改正的成本可能会很高。 </span><br><span class="line">16 + </span><br><span class="line">17 +但是“只要眼球足够多，所有Bug都好捉”， </span><br><span class="line">18 +这就是开源的哲学之一。</span><br></pre></td></tr></table></figure>
<p>为了说明方便，为每一行增添了行号。</p>
<ul>
<li><p>第1行和第2行分别记录了原始文件和目标文件的文件名及时间戳。以三个减号（—）开始的行标识的是原始文件，以三个加号（+++）开始的行标识的是目标文件。</p>
</li>
<li><p>在比较内容中，以减号（-）开始的行是只出现在原始文件中的行，例如：第4、13、14行。</p>
</li>
<li><p>在比较内容中，以加号（+）开始的行是只出现在目标文件中的行，例如：第5行和16-18行。</p>
</li>
<li><p>在比较内容中，以空格开始的行，是在原始文件和目标文件中都出现的行，例如：第6-8、10-12和第15行。这些行是用作差异比较的上下文。</p>
</li>
<li><p>第3-8行是第一个差异小节。每个差异小节以一行差异定位语句开始。第3行就是一条差异定位语句，其前后分别用两个@进行标识。</p>
</li>
<li><p>第3行定位语句中-1，4的含义是：本差异小节的内容相当于原始文件的从第1行开始的4行。而第4、6、7、8行是原始文件中的内容，加起来刚好是4行。</p>
</li>
<li><p>第3行定位语句中+1，4的含义是：本差异小节的内容相当于目标文件的从第1行开始的4行。而第5、6、7、8行是目标文件中的内容，加起来刚好是4行。</p>
</li>
<li><p>因为命令diff是用于行比较的，所以即使改正了一个字，也显示为一整行的修改（参见差异文件第4、5行）。Git对diff进行了扩展，并且还提供一种逐词比较的差异比较方法。</p>
</li>
<li><p>第9-18行是第二个差异小节。第9行是一条差异定位语句。</p>
</li>
<li><p>第9行定位语句中-6，6的含义是：本差异小节的内容相当于原始文件的从第6行开始的6行。第10-15行是原始文件中的内容，加起来刚好是6行。</p>
</li>
<li><p>第9行定位语句中+6，7的含义是：本差异小节的内容相当于目标文件的从第6行开始的7行。而第10-12、15-18行是目标文件中的内容，加起来刚好是7行。</p>
</li>
</ul>
<h3 id="git-diff常用参数"><a href="#git-diff常用参数" class="headerlink" title="git diff常用参数"></a>git diff常用参数</h3><ol>
<li>不带任何选项和参数调用git diff显示工作区的最新改动，即工作区与提交任务（提交暂存区，stage）中相比的差异。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>将工作区和HEAD（当前工作分支）相比，会看到更多的差异。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过参数–cached或–staged调用git diff命令，看到的是提交暂存区（提交任务，stage）和版本库中文件的差异。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210622112954.jpeg" alt="微信图片_20210622102452"></p>
<h3 id="git-diff里程碑比较"><a href="#git-diff里程碑比较" class="headerlink" title="git diff里程碑比较"></a>git diff里程碑比较</h3><ul>
<li>比较里程碑B和里程碑A，用命令：<code>git diff B A</code></li>
<li>比较工作区和里程碑A，用命令：<code>git diff A</code></li>
<li>比较暂存区和里程碑A，用命令：<code>git diff--cached A</code></li>
</ul>
<h3 id="git-diff扩展"><a href="#git-diff扩展" class="headerlink" title="git diff扩展"></a>git diff扩展</h3><ol>
<li><p>文件不同版本的差异比较差异比较还可以使用路径参数，只显示不同版本间该路径下文件的差异。语法格式如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; -- &lt;paths&gt;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>非Git目录&#x2F;文件的差异比较命令git diff还可以在Git版本库之外执行，对非Git目录进行比较，就像GNU的diff命令一样。之所以提供这个功能是因为Git差异比较命令更为强大，提供了对二进制文件差异等的扩展支持。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff &lt;path1&gt; &lt;path2&gt; </span><br></pre></td></tr></table></figure></li>
<li><p>逐词比较，而非默认的逐行比较Git的差异比较默认是逐行比较，分别显示改动前的行和改动后的行，到底改动在哪里还需要仔细辨别。Git还提供一种逐词比较的输出，有的人会更喜欢。使用–word-diff参数可以显示逐词比较。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff --word-diff diff --git a/src/book/02-use-git/080-git-history-travel.rst b/src/book/02-use-git/080-git-history-travel.rst </span><br><span class="line">index f740203..2dd3e6f 100644 </span><br><span class="line">--- a/src/book/02-use-git/080-git-history-travel.rst </span><br><span class="line">+++ b/src/book/02-use-git/080-git-history-travel.rst </span><br><span class="line">@@ -681，7 +681，7 @@</span><br><span class="line">Git的大部分命令可以使用提交版本作为参数（如：git diff），</span><br><span class="line">::</span><br><span class="line">  [-18:23:48 jiangxin@hp:~/gitwork/gitbook/src/book$-]&#123;+$+&#125; </span><br><span class="line">git log --stat --oneline  I..C</span><br><span class="line">  0cd7f2e commit C.    </span><br><span class="line">    README    |    1 +</span><br><span class="line">    doc/C.txt |    1 +</span><br></pre></td></tr></table></figure>
<p>上面的逐词差异显示是有颜色的：删除内容[-…-]用红色表示，添加的内容{+…+}用绿色表示。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git diff</tag>
      </tags>
  </entry>
  <entry>
    <title>git reset and git checkout</title>
    <url>/2021/06/24/git-reset-and-git-checkout/</url>
    <content><![CDATA[<blockquote>
<p>重置的默认值是HEAD，而检出的默认值是暂存区。因此重置一般用于重置暂存区（除非使用–hard参数，否则不重置工作区），而检出命令主要是覆盖工作区（如果<code>&lt;commit&gt;</code>不省略，也会替换暂存区中相应的文件）。</p>
</blockquote>
<span id="more"></span>



<h2 id="git-reset-and-git-checkout"><a href="#git-reset-and-git-checkout" class="headerlink" title="git reset and git checkout"></a>git reset and git checkout</h2><p>重置的默认值是HEAD，而检出的默认值是暂存区。因此重置一般用于重置暂存区（除非使用–hard参数，否则不重置工作区），而检出命令主要是覆盖工作区（如果<code>&lt;commit&gt;</code>不省略，也会替换暂存区中相应的文件）。</p>
<h3 id="一、git-reset"><a href="#一、git-reset" class="headerlink" title="一、git reset"></a>一、git reset</h3><ol>
<li><h4 id="git-reset命令格式"><a href="#git-reset命令格式" class="headerlink" title="git reset命令格式"></a>git reset命令格式</h4></li>
</ol>
<p>重置命令（git reset）是Git最常用的命令之一，也是最危险最容易误用的命令。来看看git reset命令的用法。 </p>
<ul>
<li><p><font color=brown>用法一：<code>git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;... </code></font></p>
</li>
<li><p><font color=brown>用法二：<code>git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;]  </code></font></p>
</li>
</ul>
<ol start="2">
<li><h4 id="git-reset命令解析"><a href="#git-reset命令解析" class="headerlink" title="git reset命令解析"></a>git reset命令解析</h4></li>
</ol>
<p>上面列出了两个用法，其中<code>&lt;commit&gt;</code>都是可选项，可以使用引用或提交ID，如果省略<code>&lt;commit&gt;</code>则相当于使用了HEAD的指向作为提交ID。</p>
<p>上面列出的两种用法的区别在于，第一种用法在命令中包含路径<code>&lt;paths&gt;</code>。为了避免路径和引用（或者提交ID）同名而发生冲突，可以在<code>&lt;paths&gt;</code>前用两个连续的短线（减号）作为分隔。</p>
<p>第一种用法（包含了路径<code>&lt;paths&gt;</code>的用法）不会重置引用，更不会改变工作区，而是用指定提交状态（<code>&lt;commit&gt;</code>）下的文件（<code>&lt;paths&gt;</code>）替换掉暂存区中的文件。例如命令<code>git reset HEAD&lt;paths&gt;</code>相当于取消之前执行的<code>git add&lt;paths&gt;</code>命令时改变的暂存区。</p>
<p>第二种用法（不使用路径<code>&lt;paths&gt;</code>的用法）则会重置引用。根据不同的选项，可以对暂存区或工作区进行重置。参照下面的版本库模型图（图1），来看一看不同的参数对第二种重置语法的影响。</p>
<p>图1：</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/4A8334536628F5AE791CDEEE34205B70.jpg" alt="4A8334536628F5AE791CDEEE34205B70"></p>
<ol start="3">
<li><h4 id="git-reset-命令的三个重要参数"><a href="#git-reset-命令的三个重要参数" class="headerlink" title="git reset 命令的三个重要参数"></a>git reset 命令的三个重要参数</h4></li>
</ol>
<p>命令格式:<code>git reset [--soft | --mixed | --hard ] [&lt;commit&gt;]</code>。 </p>
<ul>
<li><p>使用参数–hard，如：<code>git reset--hard&lt;commit&gt;</code>。会执行上图中的全部动作①、②、③，即：</p>
<ul>
<li><p>①替换引用的指向。引用指向新的提交ID。</p>
</li>
<li><p>②替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。</p>
</li>
<li><p>③替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。</p>
</li>
</ul>
</li>
<li><p>使用参数–soft，如：<code>git reset--soft&lt;commit&gt;</code>。会执行上图中的操作①。即只更改引用的指向，不改变暂存区和工作区。</p>
</li>
<li><p>使用参数–mixed或不使用参数（默认为–mixed），如：<code>git reset&lt;commit&gt;</code>。会执行上图中的操作①和操作②。即更改引用的指向及重置暂存区，但是不改变工作区。</p>
</li>
</ul>
<ol start="4">
<li><h4 id="git-reset命令。"><a href="#git-reset命令。" class="headerlink" title="git reset命令。"></a>git reset命令。</h4></li>
</ol>
<ul>
<li><p><font color = red>命令：<code>git reset</code>仅用HEAD指向的目录树重置暂存区，工作区不会受到影响，相当于将之前用git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。</font></p>
</li>
<li><p>命令：<code>git reset HEAD</code>同上。</p>
</li>
<li><p>命令：<code>git reset--filename</code>仅将文件filename的改动撤出暂存区，暂存区中其他文件不改变。相当于对命令<code>git add filename</code>的反向操作。</p>
</li>
<li><p>命令：<code>git reset HEAD filename</code>同上。</p>
</li>
<li><p>命令：<code>git reset--soft HEAD^</code>工作区和暂存区不改变，但是引用向前回退一次。当对最新提交的提交说明或提交的更改不满意时，撤销最新的提交以便重新提交。</p>
</li>
</ul>
<p> 修补提交命令<code>git commit--amend</code>，用于对最新的提交进行重新提交以修补错误的提交说明或错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件<code>.git/COMMIT_EDITMSG</code>保存了上次的提交日志。）</p>
<pre><code>$git reset --soft HEAD^
$ git commit -e -F .git/COMMIT_EDITMSG  
</code></pre>
<ul>
<li>命令：<code>git reset HEAD^</code>工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。</li>
<li>命令：<code>git reset--mixed HEAD^</code>同上。</li>
<li>命令：<code>git reset--hard HEAD^</code>彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。</li>
</ul>
<h3 id="二、git-checkout"><a href="#二、git-checkout" class="headerlink" title="二、git checkout"></a>二、git checkout</h3><ol>
<li><h4 id="git-checkout命令格式"><a href="#git-checkout命令格式" class="headerlink" title="git checkout命令格式"></a>git checkout命令格式</h4><p>检出命令（git checkout）是Git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。检出命令的用法如下： </p>
<ul>
<li><p>用法一： git checkout [-q] [<commit>] [–] <paths>… </p>
</li>
<li><p>用法二： git checkout [<branch>] </p>
</li>
<li><p>用法三： git checkout [-m] [[-b|–orphan] <new_branch>] [<start_point>]</p>
</li>
</ul>
</li>
<li><h4 id="git-checkout命令解析"><a href="#git-checkout命令解析" class="headerlink" title="git checkout命令解析"></a>git checkout命令解析</h4></li>
</ol>
<ul>
<li><p>上面列出的第一种用法和第二种用法的区别在于，第一种用法在命令中包含路径<code>&lt;paths&gt;</code>。为了避免路径和引用（或者提交ID）同名而发生冲突，可以在<code>&lt;paths&gt;</code>前用两个连续的短线（减号）作为分隔。<code>&lt;commit&gt;</code>是可选项，如果省略则相当于从暂存区（index）进行检出。</p>
</li>
<li><p>第一种用法（包含了路径<code>&lt;paths&gt;</code>的用法）不会改变HEAD头指针，主要是用于指定版本的文件覆盖工作区中对应的文件。如果省略<code>&lt;commit&gt;</code>，则会用暂存区的文件覆盖工作区的文件，否则用指定提交中的文件覆盖暂存区和工作区中对应的文件。</p>
</li>
<li><p>第二种用法（不使用路径<code>&lt;paths&gt;</code>的用法）则会改变HEAD头指针。之所以后面的参数写作<code>&lt;branch&gt;</code>，是因为只有HEAD切换到一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”的状态。在“分离头指针”状态下的提交不能被引用关联到，从而可能丢失。所以用法二最主要的作用就是切换到分支。如果省略<code>&lt;branch&gt;</code>则相当于对工作区进行状态检查。</p>
</li>
<li><p>第三种用法主要是创建和切换到新的分支（<code>&lt;new_branch&gt;</code>），新的分支从<code>&lt;start_point&gt;</code>指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在<code>refs/heads</code>命名空间下的引用。</p>
<p>如图2所示的版本库模型图描述了<code>git checkout</code>实际完成的操作。 </p>
<pre><code> 图2：
</code></pre>
</li>
</ul>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/78689BA0FA5DEFE0D1ED902F9F97932A.jpg" alt="78689BA0FA5DEFE0D1ED902F9F97932A"></p>
<ol start="3">
<li><h4 id="git-checkout命令"><a href="#git-checkout命令" class="headerlink" title="git checkout命令"></a>git checkout命令</h4></li>
</ol>
<p>检出命令与版本库关系图下面通过一些示例来具体看一下检出命令的不同用法。</p>
<ul>
<li><p>命令：<code>git checkout branch</code>检出branch分支。要完成如图2中的三个步骤，更新HEAD以指向branch分支，以及用branch指向的树更新暂存区和工作区。</p>
</li>
<li><p>命令：<code>git checkout</code>汇总显示工作区、暂存区与HEAD的差异。</p>
</li>
<li><p>命令：<code>git checkout HEAD</code>同上。</p>
</li>
<li><p>命令：<code>git checkout--filename</code>用暂存区中filename文件来覆盖工作区中的filename文件。相当于取消自上次执行git add filename以来（如果执行过）的本地修改。这个命令很危险，因为对于本地的修改会悄无声息地覆盖，毫不留情。</p>
</li>
<li><p>命令：<code>git checkout branch--filename</code>维持HEAD的指向不变。用branch所指向的提交中的filename替换暂存区和工作区中相应的文件。注意会将暂存区和工作区中的filename文件直接覆盖。</p>
</li>
<li><p>命令：<code>git checkout--.</code>或写作<code>git checkout.</code>注意　<code>git checkout</code>命令后的参数为一个点（“.”）。这条命令最危险！会取消所有本地的修改（相对于暂存区）。相当于用暂存区的所有文件直接覆盖本地文件，不给用户任何确认的机会！</p>
</li>
<li><p>命令：<code>git rm--cached</code>会直接从暂存区删除文件，工作区则不做出改变。</p>
</li>
<li><p>当执行git checkout HEAD.或git checkout HEAD命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p>
</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展 "></a><font color=blue><strong>扩展</strong> </font></h4><p><font size =4 color=blue>Git提供了很多方法可以方便地访问Git库中的对象：</font></p>
<ul>
<li><p>采用部分的SHA1哈希值。不必把40位的哈希值写全，只采用开头的部分（4位以上），只要不与现有的其他哈希值冲突即可。</p>
</li>
<li><p>使用master代表分支master中最新的提交，也可以使用全称<code>refs/heads/master</code>或<code>heads/master</code>。</p>
</li>
<li><p>使用HEAD代表版本库中最近的一次提交。</p>
</li>
<li><p>符号^可以用于指代父提交。例如：<code>HEAD^</code>代表版本库中的上一次提交，即最近一次提交的父提交。</p>
</li>
<li><p><code>HEAD^^</code> 则代表<code>HEAD^</code>的父提交。</p>
</li>
<li><p>对于一个提交有多个父提交，可以在符号^后面用数字表示是第几个父提交。</p>
</li>
</ul>
<p>例如：·<code>a573106^2</code>的含义是提交a573106的多个父提交中的第二个父提交。</p>
<ul>
<li><p><code>HEAD^1</code>相当于<code>HEAD^</code>，含义是HEAD的多个父提交中的第一个父提交。</p>
</li>
<li><p><code>HEAD^^2</code>的含义是<code>HEAD^</code>(HEAD父提交)的多个父提交中的第二个父提交。</p>
</li>
<li><p>符号<del>也可以用于指代祖先提交。例如：&#96;a573106</del>5<code>即相当于</code>a573106^^^^^&#96;。</p>
</li>
<li><p>提交所对应的树对象，可以用类似如下的语法访问：<code>a573106^&#123;tree&#125;</code></p>
</li>
<li><p>某一次提交对应的文件对象，可以用如下的语法访问：<code>a573106:path/to/file</code></p>
</li>
<li><p>暂存区中的文件对象，可以用如下的语法访问：<code>:path/to/file</code></p>
</li>
</ul>
<p><font size =4 color=blue>git reflog命令的输出中还提供了一个方便易记的表达式：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;refname&gt;@&#123;&lt;n&gt;&#125;</span><br></pre></td></tr></table></figure>



<p>这个表达式的含义是应用<refname>之前第<n>次改变时的SHAI哈希值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard master@&#123;2&#125;   #重置master为两次改变之前的值</span><br></pre></td></tr></table></figure>







<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>重置命令的一个用途就是修改引用（如master）的游标指向。实际上在执行重置命令的时候没有使用任何参数对所要重置的分支名（如master）进行设置，这是因为重置命令实际上所针对的是头指针HEAD。重置的默认值是HEAD，而检出的默认值是暂存区。因此重置一般用于重置暂存区（除非使用–hard参数，否则不重置工作区），而检出命令主要是覆盖工作区（如果<code>&lt;commit&gt;</code>不省略，也会替换暂存区中相应的文件）。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git checkout</tag>
        <tag>git reset</tag>
        <tag>检出</tag>
        <tag>重置</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages</title>
    <url>/2021/05/22/github-pages/</url>
    <content><![CDATA[<p>在用github和hexo搭建个人博客时遇到github pages。github pages是什么呢？它就是托管在github上的静态网页。建立时注意事项：</p>
<ol>
<li>仓库名和用户名相同</li>
<li>在仓库的setting找到page，把分支改为branch分支就行了</li>
</ol>
<span id="more"></span>



<h1 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h1><h3 id="1、什么是github-pages"><a href="#1、什么是github-pages" class="headerlink" title="1、什么是github pages"></a>1、什么是github pages</h3><ol>
<li>什么是github pages<br>github是项目托管网站，列出了项目的源文件，所以github 有一个pages功能，可以自定义主页，用来代替默认的列出源列表的这个页面</li>
</ol>
<blockquote>
<p>所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。</p>
</blockquote>
<ol start="2">
<li>下面是GitHub Pages 官方文档:</li>
</ol>
<p><a href="https://pages.github.com/">https://pages.github.com/</a><br><a href="http://help.github.com/pages">http://help.github.com/pages</a></p>
<ol start="3">
<li><p>GitHub提供两种类型的主页(<a href="https://help.github.com/articles/user-organization-and-project-pages">https://help.github.com/articles/user-organization-and-project-pages</a>):</p>
<ol>
<li>个人或组织主页 - 页面内容位于 main下</li>
<li>项目主页 - 页面内容位于每个项目的main下</li>
</ol>
<p>我们创建的博客属于个人页面（也可以创建为项目主页，不过默认的域名不一样，个人理解）</p>
</li>
</ol>
<h3 id="2、怎么使用github-pages"><a href="#2、怎么使用github-pages" class="headerlink" title="2、怎么使用github pages"></a>2、怎么使用github pages</h3><ol>
<li><p>使用个人或组织页面<br>使用个人或组织页面，需要先创建一个和你的账号同名的仓库，比我我的github账号是51228，那么我需要创建一个名为51228.github.io的repo，然后在master上提交你的项目代码，这样就可以通过网址：<a href="http://51228.github.io来访问我的个人博客./">http://51228.github.io来访问我的个人博客。</a></p>
</li>
<li><p>使用项目主页的方法如下</p>
<ol>
<li><p>设置的方法很简单，只需要在你项目的右上角点击setting</p>
</li>
<li><p>找到下方的pages，将默认的none改成main分支</p>
</li>
<li><p>点击保存，之后就可以在github pages后面看到你的项目链接了，你可以直接通过这个链接查看你main分支中代码的html内容</p>
</li>
</ol>
<blockquote>
<h4 id="user-pages只有一个-project-pages可以有多个-对于个人博客而言-两种方式都可以-如果用户申请了自己的域名-还可以使用CNAME文件自定义domain-name-这样访问你的域名就自动访问到github上的页面-用户也可以自定义404页面"><a href="#user-pages只有一个-project-pages可以有多个-对于个人博客而言-两种方式都可以-如果用户申请了自己的域名-还可以使用CNAME文件自定义domain-name-这样访问你的域名就自动访问到github上的页面-用户也可以自定义404页面" class="headerlink" title="user pages只有一个, project pages可以有多个, 对于个人博客而言, 两种方式都可以.如果用户申请了自己的域名, 还可以使用CNAME文件自定义domain name, 这样访问你的域名就自动访问到github上的页面. 用户也可以自定义404页面."></a>user pages只有一个, project pages可以有多个, 对于个人博客而言, 两种方式都可以.如果用户申请了自己的域名, 还可以使用CNAME文件自定义domain name, 这样访问你的域名就自动访问到github上的页面. 用户也可以自定义404页面.</h4></blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>git hub pages</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>git冲突合并</title>
    <url>/2021/06/20/git%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p>在使用<code>git push</code>的过程中，经常会遇到一个问题，因为文件有冲突无法push。冲突有几种表现形式？冲突的解决方式？本文就是解决以上问题。</p>
<span id="more"></span>

<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>一. <a href="#1">冲突类型</a></p>
<ol>
<li>自动合并</li>
<li>逻辑冲突</li>
<li>真正的冲突</li>
<li>冲突树</li>
</ol>
<p>二. <a href="#2">Git如何记录冲突</a></p>
<ol>
<li>git冲突是通过.git目录下的几个文件记录的：</li>
<li>版本库暂存区中则会记录冲突文件的多个不同版本，使用<code>git ls-files -s</code>命令查看</li>
<li>工作区的版本则可能同时包含了成功合并即冲突合并，其中冲突合并会用特殊的标记</li>
</ol>
<p>三. <a href="#3">冲突的解决</a></p>
<ol>
<li>手工编辑完成冲突解决</li>
<li>图形工具完成冲突解决</li>
</ol>
<p><a id=1>一. 冲突类型</a></p>
<ol>
<li>自动合并</li>
</ol>
<ul>
<li>修改不同的文件</li>
<li>修改相同文件的不同区域</li>
<li>同时更改文件名和文件内容</li>
</ul>
<ol start="2">
<li>逻辑冲突</li>
</ol>
<ul>
<li>典型的逻辑冲突是一个用户修改了一个文件的文件名，而另外的用户在其他文件中引用旧的文件名，这样的合并虽然能够成功但是包含着逻辑冲突。</li>
<li>一个用户修改了函数的返回值而另外的用户使用旧的函数的返回值，虽然能够成功但是存在逻辑冲突。</li>
</ul>
<ol start="3">
<li>冲突树</li>
</ol>
<ul>
<li>如果一个用户将某个文件改名，另外一个用户把文件改为另外一个名字，当两个用户提交合并操作时，产生冲突。这种因为文件名修改造成的冲突，称为树冲突。</li>
</ul>
<p><a id=2>二. Git如何记录冲突</a></p>
<ol>
<li>git冲突是通过.git目录下的几个文件记录的：</li>
</ol>
<ul>
<li>文件.git&#x2F;MERGE_HEAD记录所合并的提交ID</li>
<li>文件.git&#x2F;MERGE_MSG记录合并失败的信息</li>
<li>文件.git&#x2F;MERGE_MODE标识合并状态</li>
<li>可以使用<code>cat .git/MERGE_HEAD</code>,<code>cat .git/MERGE_MSG</code>,<code>cat .git/MERGE_MODE</code>来访问。</li>
</ul>
<ol start="2">
<li><p>版本库暂存区中则会记录冲突文件的多个不同版本，使用<code>git ls-files -s</code>命令查看：</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210620202729446.png" alt="image-20210620202729446"></p>
</li>
</ol>
<p>在上面的输出中，每一行分为四个字段，前两个分别是文件的属性和SHAI哈希值。第三个字段暂存区编号，当合并冲突发生后，会用到0以上的暂存区编号。</p>
<ul>
<li>编号为1的暂存区用于保存冲突文件修改之前的副本，即冲突双方共同的祖先版本。</li>
<li>编号为2的暂存区用于保存当前冲突文件在当前分支中修改的副本。</li>
<li>编号为3的暂存区用于保存当前冲突文件在合并版本中修改的副本。</li>
<li>对暂存区三个副本的访问方式：git show :编号:文件名<ul>
<li>编号：1，2，3，</li>
<li>文件名：_config.yml</li>
</ul>
</li>
</ul>
<ol start="3">
<li>工作区的版本则可能同时包含了成功合并即冲突合并，其中冲突合并会用特殊的标记（&lt;&lt;&lt;&lt;&lt;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;）进行标识：</li>
</ol>
<ul>
<li>特殊标识&lt;&lt;&lt;&lt;&lt;&lt;和&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;之间的内容是当前分支更改的内容。</li>
<li>特殊标识&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;和&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是所合并的版本更改的内容。</li>
</ul>
<p><a id=3>三. 冲突的解决</a><br>冲突解决的实质就是通过编辑操作，将冲突标识符所标识的冲突内容替换为合适的内容，并去掉冲突标识符。编辑完成后执行<code>git add</code>命令将文件添加到暂存区（标号0）,然后再提交就完成了冲突解决。</p>
<ol>
<li><p>手工编辑完成冲突解决</p>
<ul>
<li><p>找到冲突的地方</p>
</li>
<li><p>在工作区编辑文件冲突的地方</p>
</li>
<li><p><code>git add -u</code>，添加到暂存区</p>
</li>
<li><p><code>git commit -m &quot;冲突解决&quot;</code>,提交完成后，.git目录下与合并相关的文件.git&#x2F;MERGE_HEAD、.git&#x2F;MERGE_MSG、.git&#x2F;MERGE_MODE文件都自动删除。</p>
</li>
<li><p>执行推送</p>
</li>
</ul>
</li>
<li><p>图形工具完成冲突解决</p>
<p>第一步： 在操作系统中安装图形工具：kdiff3，meld，araxis等</p>
<p>第二步： 执行命令<code>git mergetool</code>后，会显示支持的图形工具列表。</p>
<p>第三步：启动kdiff3后，上方窗口从左至右显示冲突文件的三个版本，分别是：</p>
<p>​                A：暂存区1中的版本（共同的先祖版本）</p>
<p>​                B：暂存区2中的版本（当前分支更改的版本）</p>
<p>​                C：暂存区3中的版本（他人更改的版本）<img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210620212217851.png" alt="image-20210620212217851"></p>
</li>
</ol>
<p>  第四步：点击标记为“合并冲突”的一行，在弹出的菜单中出现A&#x2F;B&#x2F;C三个选项，分别代表从A、B、C三个窗口复制相关内容到当前位置<br>  第五步：B行代表从窗口B中复制的文件，M指手工修改的行<br>    <img src="https://gitee.com/nsaction/blog_pic/raw/master/image-20210620213323429.png" alt="image-20210620213323429"></p>
<p>  第六步：编辑完成后保存退出即完成图形化冲突解决。</p>
<p>  第七步：<code>git status</code>显示工作区状态，会看到冲突已经解决，在工作区会遗留一个以.orig结尾的合并前的文件副本,暂存区中三个文件的副本也已经清除。</p>
<p>  第八步：执行提交和推送，由于文件是在暂存区更改，所以不需要add，直接commit，再push。</p>
<ol start="3">
<li>树冲突可以采用手工操作和图形操作</li>
</ol>
<ul>
<li><p>手工操作由用户决定删除文件，保留一个文件而解决冲突。<code>git rm 文件名</code>。</p>
</li>
<li><p>图形模式交互式解决树冲突：执行<code>git mergetool</code>命令，忽略其中的提示和警告——&gt;询问对冲突文件的处理方式——&gt;输入D删除冲突文件，输入C保留冲突文件——&gt;最终解决冲突提交。</p>
</li>
</ul>
<hr>
<h3 id="总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先pull的习惯，编辑完文件再提交，减少冲突发生。"><a href="#总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先pull的习惯，编辑完文件再提交，减少冲突发生。" class="headerlink" title="总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先pull的习惯，编辑完文件再提交，减少冲突发生。"></a>总结：为了减少冲突，在我们每次在工作区编辑文件的时候，我们应该养成一个先<code>pull</code>的习惯，编辑完文件再提交，减少冲突发生。</h3>]]></content>
      <categories>
        <category>知识点</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>冲突解决</tag>
        <tag>merge</tag>
      </tags>
  </entry>
  <entry>
    <title>git疑难之一(中文显示问题）</title>
    <url>/2021/06/23/git%E7%96%91%E9%9A%BE%E4%B9%8B%E4%B8%80(%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<p>解决git中文显示问题</p>
<span id="more"></span>





<ol>
<li><p>git输出文件名时，文件名的中文不能正确显示，而是显示为八进制的字符编码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status -s </span><br><span class="line">?? &quot;\350\257\264\346\230\216.txt&quot; $ printf &quot;\350\257\264\346\230\216.txt\n&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <font size=5 color=red>解决办法：</font></p>
<p>将git配置变量core.quotepath设置为false，就可以解决文件名中的中文在这些git输出中的显示问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath false  </span><br><span class="line">git config --global core.quotepath off       #用这个也可以</span><br></pre></td></tr></table></figure>



<p><font color=blue><strong>扩展</strong>：</font></p>
<ul>
<li><p>使用以下命令，提交命令的时候使用utf-8编码集提交，这样在使用<code>git commit</code>，commit对象中嵌入正确的编码说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global i18n.commitEncoding utf-8</span><br></pre></td></tr></table></figure>



</li>
<li><p>使用以下命令，将提交说明所使用的字符集设置为utf-8，这样使用<code>git log</code>查看提交说明时才能够正确显示其中的中文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global i18n.logOutputEncoding utf-8</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>中文显示</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>git问题之二—git提示“warning: LF will be replaced by CRLF”的解决办法</title>
    <url>/2021/06/24/git%E9%97%AE%E9%A2%98%E4%B9%8B%E4%BA%8C%E2%80%94git%E6%8F%90%E7%A4%BA%E2%80%9Cwarning%20LF%20will%20be%20replaced%20by%20CRLF%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>windows平台下使用git add，git deploy 文件时经常出现“warning: LF will be replaced by CRLF” 的提示。</p>
</blockquote>
<span id="more"></span>



<blockquote>
<p><strong>参考</strong>：<a href="https://blog.csdn.net/u012757419/article/details/105614028/">https://blog.csdn.net/u012757419/article/details/105614028/</a></p>
</blockquote>
<h4 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h4><p><font size=4 color=red>windows平台下使用git add，git deploy 文件时经常出现“warning: LF will be replaced by CRLF” 的提示。</p>
</font>

<h4 id="二、分析问题"><a href="#二、分析问题" class="headerlink" title="二、分析问题"></a>二、分析问题</h4><p>其实，这是因为在文本处理中，CR（CarriageReturn），LF（LineFeed），CR&#x2F;LF是不同操作系统上使用的换行符，具体如下：</p>
<p>换行符‘\n’和回车符‘\r’</p>
<ul>
<li>回车符就是回到一行的开头，用符号r表示，十进制ASCII代码是13，十六进制代码为0x0D，回车（return）；</li>
<li>换行符就是另起一行，用n符号表示，ASCII代码是10，十六制为0x0A， 换行（newline）。</li>
</ul>
<p>所以我们平时编写文件的回车符应该确切来说叫做回车换行符。</p>
<p>应用情况</p>
<ul>
<li>Dos和Windows平台： 使用回车（CR）和换行（LF）两个字符来结束一行，回车+换行(CR+LF)，即“\r\n”；</li>
<li>Mac 和 Linux平台：只使用换行（LF）一个字符来结束一行，即“\n”；</li>
<li>最早Mac每行结尾是回车CR 即’\r’，后mac os x 也投奔了 unix。</li>
</ul>
<p>许多 Windows 上的编辑器会悄悄把行尾的换行（LF）字符转换成回车（CR）和换行（LF），或在用户按下 Enter 键时，插入回车（CR）和换行（LF）两个字符。</p>
<p>影响：</p>
<ul>
<li>一个直接后果是，Unix&#x2F;Mac系统下的文件在Windows里打开的话，所有文字会变成一行；</li>
<li>而Windows里的文件在Unix&#x2F;Mac下打开的话，在每行的结尾可能会多出一个^M符号。</li>
<li>Linux保存的文件在windows上用记事本看的话会出现黑点。</li>
</ul>
<p>这些问题都可以通过一定方式进行转换统一，例如，在linux下，命令unix2dos 是把linux文件格式转换成windows文件格式，命令dos2unix 是把windows格式转换成linux文件格式。</p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a><font color=red>解决办法：</font></h4><h5 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h5><p>Git 可以在你提交时自动地把回车（CR）和换行（LF）转换成换行（LF），而在检出代码时把换行（LF）转换成回车（CR）和换行（LF）。 你可以用 git config –global core.autocrlf true 来打开此项功能。 如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#提交时转换为LF，检出时转换为CRLF</span><br><span class="line">$ git config --global core.autocrlf true</span><br></pre></td></tr></table></figure>



<h5 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h5><p>如果使用以换行（LF）作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换。然而当一个以回车（CR）和换行（LF）作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。 所以，你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：（这样在 Windows 上的检出文件中会保留回车和换行，而在 Mac 和 Linux 上，以及版本库中会保留换行。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#提交时转换为LF，检出时不转换</span><br><span class="line">$ git config --global core.autocrlf input</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="情况三："><a href="#情况三：" class="headerlink" title="情况三："></a>情况三：</h5><p>如果你是 Windows 程序员，且正在开发仅运行在 Windows 上的项目，可以设置 false 取消此功能，把回车保留在版本库中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#提交检出均不转换</span><br><span class="line">$ git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>




<p>你也可以在文件提交时进行safecrlf检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#拒绝提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf true   </span><br><span class="line"></span><br><span class="line">#允许提交包含混合换行符的文件</span><br><span class="line">git config --global core.safecrlf false   </span><br><span class="line"></span><br><span class="line">#提交包含混合换行符的文件时给出警告</span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>



<h4 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h4><ul>
<li><blockquote>
<p><font size=4 color=purple>git 的 Windows 客户端基本都会默认设置 core.autocrlf&#x3D;true，设置core.autocrlf&#x3D;true, 只要保持工作区都是纯 CRLF 文件，编辑器用 CRLF 换行，就不会出现警告了；</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4 color=purple>Linux 最好不要设置 core.autocrlf，因为这个配置算是为 Windows 平台定制；</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4 color=purple>Windows 上设置 core.autocrlf&#x3D;false，仓库里也没有配置 .gitattributes，很容易引入 CRLF 或者混合换行符（Mixed Line Endings，一个文件里既有 LF 又有CRLF）到版本库，这样就可能产生各种奇怪的问题。</font></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
        <category>疑难</category>
      </categories>
      <tags>
        <tag>LF</tag>
        <tag>CR</tag>
        <tag>git add</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署的原理和步骤</title>
    <url>/2021/05/23/hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<blockquote>
<h4 id="Hexo-是一个快速、简洁且高效的博客框架。Hexo-使用-Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。"><a href="#Hexo-是一个快速、简洁且高效的博客框架。Hexo-使用-Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。" class="headerlink" title="Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。"></a>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</h4></blockquote>
<span id="more"></span>



<h1 id="hexo部署的原理和步骤"><a href="#hexo部署的原理和步骤" class="headerlink" title="hexo部署的原理和步骤"></a>hexo部署的原理和步骤</h1><hr>
<h2 id="本文将从以下几个方面尝试分析。"><a href="#本文将从以下几个方面尝试分析。" class="headerlink" title="本文将从以下几个方面尝试分析。"></a>本文将从以下几个方面尝试分析。</h2><ul>
<li><p>hexo原理</p>
<ul>
<li>hexo的文件夹结构</li>
<li>hexo的工作原理</li>
</ul>
</li>
<li><p>hexo模板引擎</p>
<ul>
<li>hexo的模板引擎</li>
<li>数据填充</li>
<li>使用yaml编写的配置文件</li>
<li>配置文件中数据的使用</li>
<li>使用markdown编写的博客文章</li>
</ul>
</li>
<li><p>hexo发布</p>
</li>
<li><p>hexo常用命令</p>
</li>
<li><p>hexo变量</p>
<ul>
<li><p>hexo变量</p>
</li>
<li><p>页面变量</p>
</li>
<li><p>Post(post) 变量</p>
</li>
<li><p>首页(index)</p>
</li>
<li><p>归档页(archive)</p>
</li>
</ul>
</li>
</ul>
<h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><p>内容是一个博客的灵魂。</p>
<h4 id="1-hexo的文件夹结构"><a href="#1-hexo的文件夹结构" class="headerlink" title="1. hexo的文件夹结构"></a>1. hexo的文件夹结构</h4><p>├── _config.yml<br>├── db.json<br>├── node_modules<br>├── package.json<br>├── public<br>├── scaffolds<br>├── source #所有文章文件放在这里<br>└── themes #主题文件夹</p>
<ul>
<li><p><strong>_config.yml</strong>：该文件是hexo 的<code>站</code>级配置文件。所谓站级配置文件是指，对整个站点起效果的配置文件。</p>
</li>
<li><p><strong>source目录</strong>：该目录存放源文件。即用户编写的博文都放在该目录下。在该目录下又有几个子目录我们来分别看一下。</p>
<ul>
<li><p><strong>_post</strong>：用于存放博文，基本上每篇文章都是由Markdown语法编写的。</p>
</li>
<li><p><strong>tags</strong>：存放tag 的文件。hexo中的tags是自动生成的，所以我们不用手动修改tags目录下的index.md文件，在发布时它会自动生成。</p>
</li>
<li><p><strong>categories</strong>：存放<strong>分类</strong>。它与tags是类似的，也是自动生成的，所以不需要我们手工修改。</p>
</li>
</ul>
</li>
<li><p><strong>themes目录</strong>：该目录用于存放主题，目前hexo中最热门的主题就是<strong>next</strong>了。最近的 next release 版本是 7.8 。</p>
</li>
<li><p><strong>public目录</strong>：该目录存放hexo转出的文件，如html、css、js等。</p>
</li>
<li><p><strong>scaffolds目录</strong>：它里面存放了一些<strong>“脚手架”</strong>程序，用于生成模板页面，如执行<code>hexo new &quot;title&quot;</code>时，就会生成一个Markdown文件模板。</p>
</li>
<li><p><strong>db.json</strong> ： 缓存文件</p>
</li>
<li><p><strong>node_modules</strong>：  安装的插件以及hexo所需的一些node.js模块。</p>
</li>
<li><p><strong>package.json</strong>： 应用程序信息，配置hexo运行需要的js包。</p>
</li>
</ul>
<h4 id="2-Hexo-的工作原理"><a href="#2-Hexo-的工作原理" class="headerlink" title="2. Hexo 的工作原理"></a>2. Hexo 的工作原理</h4><h5 id="1-hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步"><a href="#1-hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步" class="headerlink" title="1) hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:"></a>1) hexo最基本的功能是将Markdown程序转成HTML页面，而这个转换并不是一次完成的，要经历两步:</h5><ul>
<li>第一步，将Markdown翻译成下面格式的JSON对象：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">article: &#123;</span><br><span class="line">  title:</span><br><span class="line">  date:</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line">  content:</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，根据上面生成的JSON对象生成 HTML 页面。</p>
<p>对于我们来说，清楚了上面hexo将Markdown转HTML页面的过程后，我们就很容易理解hexo 在执行不同命令时它都在做什么事儿了。</p>
<p>下面我们再来看看<strong>hexo</strong>的组成，它由三部分组成: <strong>hexo-cli</strong>、<strong>hexo-core</strong>以及<strong>hexo plugs</strong>。在这三部分中最核心的是hexo-core模块，它的作用就是执行上面讲的两步转换，从而生成目标文件；hexo-cli为我们供了一些非常方便的命令。当我们敲入命令时，它会根据命令调用不同的模块；hexo plugin是hexo的扩展，当hexo本身不能完成某项任务时，它允许你自己开发一个插件来完成。当然你也可以使用其它人写好的插件。</p>
<h5 id="2-这里我们来分析一下-Hexo-每次部署的流程"><a href="#2-这里我们来分析一下-Hexo-每次部署的流程" class="headerlink" title="2) 这里我们来分析一下 Hexo 每次部署的流程"></a>2) 这里我们来分析一下 Hexo 每次部署的流程</h5><ol>
<li>hexo g：生成静态文件。将我们的数据和界面相结合生成静态文件的过程：会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</li>
<li>hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</li>
<li>在node_modules中有一系列的文件用于对hexo中的各类页面进行默认的渲染，如果要启动个性化主页，需要删除hexo-generator-index,同时，将主题目录下的source目录作为你个性化页面的根目录。</li>
</ol>
<h2 id="二、模板引擎"><a href="#二、模板引擎" class="headerlink" title="二、模板引擎"></a>二、模板引擎</h2><p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p>
<h4 id="1-hexo的模板引擎"><a href="#1-hexo的模板引擎" class="headerlink" title="1. hexo的模板引擎"></a>1. hexo的模板引擎</h4><ul>
<li><p>我们可以注意到，在 Hexo 中，source 文件夹和 themes 文件夹是在同级的，我们就可以将 source 文件夹理解为数据库，而主题文件夹相当于 界面。然后我们 hexo g 就将我们的数据和界面相结合生成静态文件 public。</p>
</li>
<li><p>hexo默认的是使用ejs，同类型的东西还有很多，比如jade，swig。我选用主题是用jade的。hexo首先会解析md文件，然后根据layout判断布局类型，再调用其他的文件，这样每一块的  内容都是独立的，提高代码的复用性。最终会生成一个html页面。</p>
</li>
<li><p>jade采用缩进语法格式，和python比较类似，看上去也很舒服，我比较喜欢这种风格。在hexo中使用jade需要安装相应的模块，否则无法使用。</p>
</li>
<li><p>模板文件在 layout 文件夹下，layout 文件文档结构如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── _custom                           #通用布局</span><br><span class="line">├── _layout.swig                      #默认布局布局</span><br><span class="line">├── _macro                            #插件模板</span><br><span class="line">├── _partials                         #局部布局</span><br><span class="line">├── _scripts                         # script模板</span><br><span class="line">├── _third-party                      # 第三方插件模板</span><br><span class="line">├── archive.swig                      # 归档模板</span><br><span class="line">├── category.swig                     # 分类模板</span><br><span class="line">├── index.swig                        # 首页模板</span><br><span class="line">├── page.swig                         # 其他模板</span><br><span class="line">├── photo.swig                        # 照片模板（自定义）</span><br><span class="line">├── post.swig                         #文章模板</span><br><span class="line">├── schedule.swig                   # 归档模板</span><br><span class="line">└── tag.swig                          #标签模板</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个模板都默认使用layout布局，您可在文章的前置申明中指定其他布局，比如“post”或者“page”或是设为false来关闭布局功能（如果不填默认是post，这个在_config.yml中可以设置默认值），您甚至可在布局中再使用其他布局来建立嵌套布局。</p>
</li>
<li><p>在我们新建页面或者新建文章的使用可以选定我们使用的模板。<code>hexo new [layout] &lt;title&gt;</code>就会使用对应的模板。</p>
</li>
<li><p>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</p>
</li>
</ul>
<h4 id="2-数据的填充"><a href="#2-数据的填充" class="headerlink" title="2. 数据的填充"></a>2. 数据的填充</h4><p>数据的填充主要是 hexo -g 的时候将数据传递给 swig 模板，然后再由 swig 模板填充到 HTML 中。</p>
<h4 id="3-使用yaml编写的配置文件"><a href="#3-使用yaml编写的配置文件" class="headerlink" title="3. 使用yaml编写的配置文件"></a>3. 使用yaml编写的配置文件</h4><ul>
<li><p>yaml是专门用来写配置文件的语言。它用首行缩进表示层级关系，便于读写理解。</p>
</li>
<li><p>配置文件一般用来对所需环境进行设置。hexo中涉及到两个配置文件，一个是位于主目录下的，另一个是位于主题目录下的。</p>
</li>
<li><p>通常主目录下的配置文件用于对全站的配置，比如站点的基本信息，文章的布局，写作的格式，部署到github上的参数等等。</p>
</li>
<li><p>而主题目录下的配置文件用于对该主题的配置，比如站点导航栏的设置，一些插件的设置等。</p>
</li>
</ul>
<p>Hexo 的配置文件 _config.yml 使用 yml语法 。例如博客的名字、副标题等等之类。这些数据项组织在 config 对象中。可以数字、字符串、对象、数组。</p>
<h4 id="4-配置文件中数据的使用"><a href="#4-配置文件中数据的使用" class="headerlink" title="4. 配置文件中数据的使用"></a>4. 配置文件中数据的使用</h4><p>如果要在模板中使用某个具体的值，比如字符串、数字、逻辑变量或者对象的某个成员，可以在主题的模板文件 swig 中直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; page.title &#125;&#125; | &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-使用markdown编写的博客文章"><a href="#5-使用markdown编写的博客文章" class="headerlink" title="5. 使用markdown编写的博客文章"></a>5. 使用markdown编写的博客文章</h4><p>之所以选择hexo做博客一个原因就是它支持markdown。用markdown写文章感觉特别爽，只需要记住简单的几个语法，而且可以把全部的注意力放在文字本身上，而不用去过多的关注排版。</p>
<h2 id="三、hexo发布页面"><a href="#三、hexo发布页面" class="headerlink" title="三、hexo发布页面"></a>三、<strong>hexo发布页面</strong></h2><p>我们可以使用<code>hexo d</code>命令将生成的目标文件发布出来，但在使用它之前，你需要在站节点的_config.yml文件中配置发布的方法。我们举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git #leancloud_counter_security_sync #git</span><br><span class="line">  repo: git@github.com:avdance/avdance.github.io.git</span><br></pre></td></tr></table></figure>

<p>当我们执行<code>hexo d</code>命令时，它会调用 hexo 中的 <code>hexo-deployer-git</code> 插件。在该插件内部会启动一个进程调用<code>git</code>命令，从而将生成的html等代码上传到 github上。</p>
<p>这里可能有些同学会有疑问，为什么上传到github上就算是发布了呢？这是因为github为我们提供了免费的个人博客空间。只要你在github上创建一个<code>用户名.github.io</code>的项目，github就会自动将这个项目中的文件发布出来。</p>
<p>当然你也可以采用传输的方式，自己购买台云主机，然后在云主机上用ngnix、nodejs等搭建一个Web服务，最终将页面发布出来。</p>
<h2 id="四、hexo的常用命令"><a href="#四、hexo的常用命令" class="headerlink" title="四、hexo的常用命令"></a>四、<strong>hexo的常用命令</strong></h2><p><strong>hexo</strong> 提供了几个常用命令，如<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code>等等。下面我们分别看一下这几个命令的具体作用是什么：</p>
<ul>
<li>hexo clean: 删除 hexo 生成的所有文档。当我们执行这个命令后，你会发现public目录被删除了。</li>
<li>hexo g: 根据 source 目录中的文件生成html等可以发布的文件。</li>
<li>hexo s: 在本地起动 <strong>http</strong> 服务，将生成的 html 等输出文件布署到本地服务器上。</li>
<li>hexo d: 将生成的html代码推送到 github 上</li>
</ul>
<h2 id="五、Hexo-中的变量"><a href="#五、Hexo-中的变量" class="headerlink" title="五、Hexo 中的变量"></a>五、Hexo 中的变量</h2><h4 id="1、Hexo-中的变量"><a href="#1、Hexo-中的变量" class="headerlink" title="1、Hexo 中的变量"></a>1、Hexo 中的变量</h4><p>Hexo 提供了很多的变量，比如我们上面使用的 page 变量，还有 site 变量等，这些都是Hexo 提供的，我们可以拿来直接使用的，常用的变量有：</p>
<ul>
<li>site：对应整个网站的变量，一般会用到 site.posts.length 制作分页器。</li>
</ul>
<ol>
<li>site.posts 所有文章</li>
<li>site.pages 所有分页</li>
<li>site.categories 所有分类</li>
<li>site.tags 所有标签</li>
</ol>
<ul>
<li>page：存放当前页面的信息，例如我在 index.ejs 中使用 page.posts 获取了当前页面的所有文章而不是使用 site.posts。</li>
<li>config：config 变量我们在主目录下配置文件 _config.yml 中保存的信息。</li>
<li>theme：theme 变量是我们在主题目录下配置文件 _config.yml 中保存的信息。</li>
<li>path：当前页面的路径（不含根路径）。</li>
<li>url：页面完整网址。</li>
</ul>
<h4 id="2、页面变量"><a href="#2、页面变量" class="headerlink" title="2、页面变量"></a>2、页面变量</h4><p>Page(page) 这里指的是<code>hexo new page</code>创建的那个页面</p>
<ul>
<li>page.title：文章标题</li>
<li><a href="https://link.zhihu.com/?target=http://page.date">page.date</a>：文章建立日期</li>
<li>page.updated：文章更新日期</li>
<li>page.comments：留言是否开启</li>
<li>page.layout：布局名称</li>
<li>page.content：文章完整内容</li>
<li>page.excerpt：文章摘要</li>
<li>page.more：除了摘要的其他内容</li>
<li>page.source：文章原始路劲</li>
<li>page.full_source：文章完整原始路径</li>
<li>page.path：文章网址（不含根路径），通常在主题中使用url_for(page.path)</li>
<li>page.permalink：文章永久网址</li>
<li>page.prev：上一篇文章，如果此为第一篇文章则为null</li>
<li><a href="https://link.zhihu.com/?target=http://page.next">page.next</a>：下一篇文章，如果此为最后一篇文章则为null</li>
<li>page.raw：文章原始内容</li>
<li><a href="https://link.zhihu.com/?target=http://page.photos">page.photos</a>：文章的照片（用于相册）</li>
<li><a href="https://link.zhihu.com/?target=http://page.link">page.link</a>：文章的外链（用于链接文章）</li>
</ul>
<h4 id="3、Post-post-变量"><a href="#3、Post-post-变量" class="headerlink" title="3、Post(post) 变量"></a>3、Post(post) 变量</h4><p>这里指的是文章页面，与page布局相同，添加如下变量：</p>
<ul>
<li>page.pulished：文章非草稿为true</li>
<li>page.categories：文章分类</li>
<li>page.tags：文章标签</li>
</ul>
<h4 id="4、首页-index"><a href="#4、首页-index" class="headerlink" title="4、首页(index)"></a>4、首页(index)</h4><ul>
<li>page.per_page：每一页显示的文章数</li>
<li><a href="https://link.zhihu.com/?target=http://page.total">page.total</a>：文章数量</li>
<li>page.current：当前页码</li>
<li>page.current_url：当前页的URL</li>
<li>page.posts：当前页的文章</li>
<li>page.prev：前一页页码，如果为第一页，该值为0</li>
<li>page.prev_link：前一页URL，如果为第一页，则为’’</li>
<li><a href="https://link.zhihu.com/?target=http://page.next">page.next</a>：后一页页码，如果为最后一页，则为0</li>
<li>page.next_link：后一页URL，如果为最后一页，则为’’</li>
<li>page.path：当前页网址（不含根路径），通常在主题中使用url_for(page.path)</li>
</ul>
<h4 id="5、归档页-archive"><a href="#5、归档页-archive" class="headerlink" title="5、归档页(archive)"></a>5、归档页(archive)</h4><p>与index布局相同，但是新增如下变量：</p>
<ul>
<li><code>archive</code> 为true</li>
<li><code>year</code> 归档年份（4位）</li>
<li><code>month</code> 归档月份（不包含0）</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown如何实现锚点功能</title>
    <url>/2021/06/20/markdown%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%94%9A%E7%82%B9%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>之前看了几片文章， markdown 里面设置锚点步骤及用法都比较模糊，经过实验，将markdown锚点方法做如下分享。</p>
<span id="more"></span>

<p>参考链接：</p>
<blockquote>
<p><a href="https://blog.csdn.net/wangzhibo666/article/details/88731227">https://blog.csdn.net/wangzhibo666/article/details/88731227</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_41910694/article/details/91629999">https://blog.csdn.net/weixin_41910694/article/details/91629999</a></p>
</blockquote>
<p><a href="#qianyan">前言</a></p>
<p><a href="#fangfa">方法</a></p>
<p><a href="#cankao">参考</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a id="qianyan">前言</a></h2><p>之前看了几片文章， markdown 里面设置锚点步骤及用法都比较模糊，经过实验，将markdown锚点方法做如下分享。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><span id="fangfa">方法</span></h2><p>MarkDown页面内跳转语法</p>
<p>方法一:</p>
<ul>
<li>第一步:在需要跳转到的位置添加锚点，语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步:在需要点击跳转的位置，使用上面的id，格式类似超链接的形式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转](#jump)</span><br></pre></td></tr></table></figure>

<p>方法二:</p>
<p>第一步:在需要跳转到的位置添加锚点，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#测试2&quot;&gt;测试2&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>第二步:在需要点击跳转的位置，使用上面的id，格式类似超链接的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a id=&quot;测试2&quot;&gt;测试2&lt;/a&gt;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a id="cankao">参考</a></h2><p>[Markdown]页面添加锚点,跳到本页指定位置</p>
<h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 标题</span><br><span class="line"></span><br><span class="line">## 目录</span><br><span class="line">1. [目录1](#jump1)</span><br><span class="line">2. [目录2](#jump2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &lt;span id=&quot;jump1&quot;&gt;1. 目录1&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">### &lt;span id=&quot;jump2&quot;&gt;2. 目录2&lt;/span&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>应用</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>锚点</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml语法</title>
    <url>/2021/05/22/yaml%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在用hexo和github搭建博客的过程中遇到config.yml文件，这种文件的格式看起来非常简单明了，但这个文件到处都是坑，最大的坑是冒号“：”后的空格；缩进的空格。</p>
<span id="more"></span>


<h3 id="一、yaml语法简介："><a href="#一、yaml语法简介：" class="headerlink" title="一、yaml语法简介："></a>一、yaml语法简介：</h3><p>YAML（&#x2F;ˈjæməl&#x2F;，尾音类似 camel 骆驼）是一个可读性高，用来表达数据序列化的格式。YAML 参考了其他多种语言，包括： C 语言、 Python、Perl，并从 XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans 在 2001 年首次发表了这种语言 ，另外 Ingy döt Net 与 Oren Ben-Kiki 也是这语言的共同设计者 。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。</p>
<p>YAML (YAML Aint Markup Language)是一种标记语言，通常以.yml或者.yaml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C&#x2F;C++, Ruby, Python, Perl, C#, PHP等。</p>
<h3 id="二、YML的优点"><a href="#二、YML的优点" class="headerlink" title="二、YML的优点"></a>二、YML的优点</h3><ol>
<li>YAML易于人们阅读。</li>
<li>YAML数据在编程语言之间是可移植的。</li>
<li>YAML匹配敏捷语言的本机数据结构。</li>
<li>YAML具有一致的模型来支持通用工具。</li>
<li>YAML支持单程处理。</li>
<li>YAML具有表现力和可扩展性。</li>
<li>YAML易于实现和使用。</li>
</ol>
<h3 id="三、YML语法"><a href="#三、YML语法" class="headerlink" title="三、YML语法"></a>三、YML语法</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.<strong>语法</strong></h4><ul>
<li>k: v 表示键值对关系，<strong>冒号后面必须有一个空格</strong></li>
<li>使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是同一个层级的</li>
<li>大小写敏感</li>
<li><em><strong>缩进时不允许使用Tab键，只允许使用空格。</strong></em></li>
<li>YAML 使用可打印的 Unicode 字符，可使用 UTF-8 或 UTF-16。</li>
<li>注解由井字号（ # ）开始，可以出现在一行中的任何位置，而且范围只有一行（也就是一般所谓的单行注解）</li>
<li>每个清单成员以单行表示，并用短杠 + 空白（ -   ）起始。或使用方括号（ [ ] ），并用逗号 + 空白（ ,   ）分开成员。</li>
<li>每个散列表的成员用冒号 + 空白（ :   ）分开键值和内容。或使用大括号（ {   } ），并用逗号 + 空白（ ,   ）分开。</li>
<li>散列表的键值可以用问号 ( ? ) 起始，用来明确的表示多个词汇组成的键值。</li>
<li>字符串平常并不使用引号，但必要的时候可以用双引号 ( “ ) 或单引号 ( ‘ ) 框住。</li>
<li>使用双引号表示字符串时，可用倒斜线（ \ ）开始的转义字符（这跟 C 语言类似）表示特殊字符。</li>
<li>区块的字符串用缩进和修饰符（非必要）来和其他数据分隔，有新行保留（preserve）（使用符号 | ）或新行折叠（flod）（使用符号 &gt; ）两种方式。</li>
<li>在单一文件中，可用连续三个连字号（—）区分多个文件。</li>
<li>另外，还有选择性的连续三个点号（ … ）用来表示文件结尾。</li>
<li>重复的内容可使从参考标记星号 ( * ) 复制到锚点标记（ &amp; ）。</li>
<li>指定格式可以使用两个惊叹号 ( !! )，后面接上名称。</li>
<li>文件中的单一文件可以使用指导指令，使用方法是百分比符号 ( % )。有两个指导指令在 YAML1.1 版中被定义：</li>
<li>% YAML 指导指令，用来识别文件的 YAML 版本。</li>
<li>% TAG 指导指令，被用在 URI 的前缀标记。这个方法在标记节点的类型时相当有用。</li>
<li>YAML 在使用逗号及冒号时，后面都必须接一个空白字符，所以可以在字符串或数值中自由加入分隔符号（例如：5,280 或 <a href="https://links.jianshu.com/go?to=http://www.wikipedia.org">http://www.wikipedia.org</a>）而不  需要使用引号。</li>
</ul>
<h4 id="2、基本类型："><a href="#2、基本类型：" class="headerlink" title="2、基本类型："></a>2、基本类型：</h4><p>yaml中有以下基本类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串</span><br><span class="line">整型</span><br><span class="line">浮点型</span><br><span class="line">布尔型</span><br><span class="line">null</span><br><span class="line">时间</span><br><span class="line">日期</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-键值关系"><a href="#3-键值关系" class="headerlink" title="3. 键值关系"></a>3. <strong>键值关系</strong></h4><p>(以Java语言为例，其它语言类似)对于键与值主要是看能否表示以下内容。普通的值(数字、字符串、布尔)、日期、对象、数组、集合等。</p>
<h5 id="1-普通值-字面量"><a href="#1-普通值-字面量" class="headerlink" title="1)  普通值(字面量)"></a>1)  普通值(字面量)</h5><ul>
<li><p>k: v：字面量直接写；</p>
</li>
<li><p>字符串默认不用加上单引号或者双引号；</p>
</li>
<li><p>“”: 双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
</li>
<li><p>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi</p>
</li>
<li><p>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name1: zhangsan</span><br><span class="line">name2: &#x27;zhangsan \n lisi&#x27;</span><br><span class="line">name3: &quot;zhangsan \n lisi&quot;</span><br><span class="line">age: 18</span><br><span class="line">flag: true</span><br></pre></td></tr></table></figure>



<h5 id="2-日期"><a href="#2-日期" class="headerlink" title="2) 日期"></a>2) 日期</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date: 2019/01/01</span><br></pre></td></tr></table></figure>



<h5 id="3-清单（数组）"><a href="#3-清单（数组）" class="headerlink" title="3) 清单（数组）"></a>3) 清单（数组）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 最喜爱的电影</span><br><span class="line">- Casablanca</span><br><span class="line">- North by Northwest</span><br><span class="line">- Notorious</span><br></pre></td></tr></table></figure>

<p>行内写法：另外还有一种内置格式（inline format）可以选择用方括号围住，并用逗号 + 空白区隔（类似 JSON 的语法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 购物清单</span><br><span class="line">[milk, pumpkin pie, eggs, juice]</span><br></pre></td></tr></table></figure>



<h5 id="4-散列表"><a href="#4-散列表" class="headerlink" title="4) 散列表"></a>4) 散列表</h5><p>键值和数据由冒号及空白字符分开。区块形式（常使用与 YAML 数据文档中）使用缩进和换行符分隔 key: value 对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 区块形式</span><br><span class="line">   name: John Smith</span><br><span class="line">   age: 33</span><br></pre></td></tr></table></figure>

<p>内置形式（常使用与 YAML 数据流中）在大括号中使用逗号 + 空白字符分隔 key: value 对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- # 內置形式</span><br><span class="line"> &#123;name: John Smith, age: 33&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-对象-属性和值-、Map-键值对"><a href="#5-对象-属性和值-、Map-键值对" class="headerlink" title="5) 对象(属性和值)、Map(键值对)"></a>5) 对象(属性和值)、Map(键值对)</h5><p>在下一行来写对象的属性和值的关系，注意缩进</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people:</span><br><span class="line">    name: zhangsan</span><br><span class="line">    age: 20</span><br></pre></td></tr></table></figure>

<p>行内写法：另外还有一种内置格式（inline format）可使用大括号（ {   } ），并用逗号 + 空白（ ,   ）分开（类似 JSON 的语法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">people: &#123;name: zhangsan,age: 20&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-数组、list、set"><a href="#6-数组、list、set" class="headerlink" title="6) 数组、list、set"></a>6) 数组、list、set</h5><p>用- 值表示数组中的一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets:</span><br><span class="line">    - dog</span><br><span class="line">    - pig</span><br><span class="line">    - cat</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>行内写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pets: [dog,pig,cat]</span><br></pre></td></tr></table></figure>



<h5 id="7-数组对象、list对象、set对象"><a href="#7-数组对象、list对象、set对象" class="headerlink" title="7) 数组对象、list对象、set对象"></a>7) 数组对象、list对象、set对象</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peoples:</span><br><span class="line">    - name: zhangsan</span><br><span class="line">      age: 22</span><br><span class="line">    - name: lisi</span><br><span class="line">      age: 20</span><br><span class="line">    - &#123;name: wangwu,age: 18&#125;</span><br></pre></td></tr></table></figure>



<h5 id="8-区块的字符"><a href="#8-区块的字符" class="headerlink" title="8) 区块的字符"></a>8) 区块的字符</h5><p>再次强调，字符串不需要包在引号之内。有两种方法书写多行文字（multi-line strings），一种可以保存新行（使用 | 字符），另一种可以折叠新行（使用 &gt; 字符）。</p>
<h6 id="保存新行-Newlines-preserved"><a href="#保存新行-Newlines-preserved" class="headerlink" title="保存新行 (Newlines preserved)"></a>保存新行 (Newlines preserved)</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data: |                                     # 译者注：这是一首著名的五行民谣(limerick)</span><br><span class="line">   There once was a man from Darjeeling     # 这里曾有一个人來自大吉岭</span><br><span class="line">   Who got on a bus bound for Ealing        # 他搭上一班往伊灵的公车</span><br><span class="line">       It said on the door                  # 门上这么说的</span><br><span class="line">       &quot;Please don&#x27;t spit on the floor&quot;     # &quot;请勿在地上吐痰&quot;</span><br><span class="line">   So he carefully spat on the ceiling      # 所以他小心翼翼的吐在天花板上</span><br></pre></td></tr></table></figure>

<p>根据设置，前方的引领空白符号（leading white space）必须排成条状，以便和其他数据或是行为（如示例中的缩进）明显区分。</p>
<h6 id="折叠新行-Newlines-folded"><a href="#折叠新行-Newlines-folded" class="headerlink" title="折叠新行 (Newlines folded)"></a>折叠新行 (Newlines folded)</h6><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">data: &gt;</span><br><span class="line">   Wrapped text         <span class="meta"># 摺疊的文字</span></span><br><span class="line">   will be folded       <span class="meta"># 將會被收</span></span><br><span class="line">   <span class="keyword">into</span> a single        <span class="meta"># 進單一一個</span></span><br><span class="line">   paragraph            <span class="meta"># 段落</span></span><br><span class="line">   </span><br><span class="line">   Blank lines denote   <span class="meta"># 空白的行代表</span></span><br><span class="line">   paragraph breaks     <span class="meta"># 段落之間的區隔</span></span><br></pre></td></tr></table></figure>

<p>和保存新行不同的是，换行字符会被转换成空白字符。而引领空白字符则会被自动消去。</p>
<h5 id="9-层次结构化的元素"><a href="#9-层次结构化的元素" class="headerlink" title="9) 层次结构化的元素"></a>9) 层次结构化的元素</h5><p>清单中使用散列表</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">- &#123;name: John Smith, age: <span class="number">33</span>&#125;</span><br><span class="line">- name: Mary Smith</span><br><span class="line">  age: <span class="number">27</span></span><br></pre></td></tr></table></figure>

<h6 id="散列表中使用清单"><a href="#散列表中使用清单" class="headerlink" title="散列表中使用清单"></a>散列表中使用清单</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">men: [John Smith, Bill Jones]</span><br><span class="line">women:</span><br><span class="line">  - Mary Smith</span><br><span class="line">  - Susan Williams</span><br></pre></td></tr></table></figure>



<h3 id="四、YAML-的高级组件"><a href="#四、YAML-的高级组件" class="headerlink" title="四、YAML 的高级组件"></a>四、YAML 的高级组件</h3><p>这部分算是一个后续的讨论，在比较各种数数据列语言时，YAML 最常被提到的特色有两个：关系树和数据形态。</p>
<h4 id="树状结构之间的交互引用"><a href="#树状结构之间的交互引用" class="headerlink" title="树状结构之间的交互引用"></a>树状结构之间的交互引用</h4><h5 id="数据合并和参考"><a href="#数据合并和参考" class="headerlink" title="数据合并和参考"></a>数据合并和参考</h5><p>为了维持文件的简洁，并避免数据输入的错误，YAML 提供了结点参考（*）和散列合并（&lt;&lt;）参考到其他结点标签的锚点标记（&amp;）。参考会将树状结构加入锚点标记的内容，并可以在所有数据结构中运作（可以参考上面 “ship-to” 的示例）合并只有散列表可以使用，可以将键值自锚点标记复制到指定的散列表中。</p>
<p>当数据被 instantiate 合并和参考会被剖析器自动展开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#眼部雷射手術之標準程序</span><br><span class="line">---</span><br><span class="line">- step:  &amp;id001                  # 定義錨點標籤 &amp;id001</span><br><span class="line">    instrument:      Lasik 2000</span><br><span class="line">    pulseEnergy:     5.4</span><br><span class="line">    pulseDuration:   12</span><br><span class="line">    repetition:      1000</span><br><span class="line">    spotSize:        1mm</span><br><span class="line"></span><br><span class="line">- step:</span><br><span class="line">     &lt;&lt;: *id001                  # 合併鍵值：使用在錨點標籤定義的內容</span><br><span class="line">     spotSize:       2mm         # 覆寫&quot;spotSize&quot;鍵值</span><br><span class="line"></span><br><span class="line">- step:</span><br><span class="line">     &lt;&lt;: *id001                  # 合併鍵值：使用在錨點標籤定義的內容</span><br><span class="line">     pulseEnergy:    500.0       # 覆寫鍵值</span><br><span class="line">     alert: &gt;                    # 加入其他鍵值</span><br><span class="line">           warn patient of </span><br><span class="line">           audible pop</span><br></pre></td></tr></table></figure>

<h5 id="数据形态"><a href="#数据形态" class="headerlink" title="数据形态"></a>数据形态</h5><p>由于自动判定数据形态的功能，严格类型（也就是用户有宣告的数据形态）很难在大部分的 YAML 文件中看到。数据类型可以被区分成三大类：原码（core），定义（defined），用户定义（user-defined）。原码可以自动被解析器分析（例如：浮点数，整数，字符串，清单，映射，…）。有一些高级的数据形态──例如比特数据──在 YAML 中有被 “定义”，但不是每一种解析器都有支持。最后，YAML 支持用户自定的区域变量，包括：自定义的类别，结构或基本类型（例如：四倍精度的浮点数）。</p>
<h5 id="强制转型"><a href="#强制转型" class="headerlink" title="强制转型"></a>强制转型</h5><p>YAML 的自动判定数据形态是哪一种实体。但有时用户会想要将数据强制转型成自定的某种类型。最常见的状况是字符串，有时候可能看起来像数字或布尔值，这种时候可以使用双引号，或是使用严格类型标签。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">a: <span class="number">123</span>                     # 整數</span><br><span class="line">b: <span class="string">&quot;123&quot;</span>                   # 字串（使用雙括號）</span><br><span class="line">c: <span class="number">123.0</span>                   # 浮點數</span><br><span class="line">d: !!<span class="keyword">float</span> <span class="number">123</span>             # 浮點數，使用!!表達的嚴格型態</span><br><span class="line">e: !!str <span class="number">123</span>               # 字串，使用嚴格型態</span><br><span class="line">f: !!str Yes               # 字串，使用嚴格型態</span><br><span class="line">g: Yes                     # 布林值<span class="string">&quot;真&quot;</span></span><br><span class="line">h: Yes we have No bananas  # 字串（包含<span class="string">&quot;Yes&quot;</span>和<span class="string">&quot;No&quot;</span>）</span><br></pre></td></tr></table></figure>



<h5 id="其他特殊数据形态"><a href="#其他特殊数据形态" class="headerlink" title="其他特殊数据形态"></a>其他特殊数据形态</h5><p>除了一般的数据形态之外，用户也可以使用一些较为高级的类型，但不保证可被每种解析器分析。使用时和强制转型类似，要在形态名称之前加上两个惊叹号（!!）。有几种重要的形态在本篇没有讨论，包括集合（sets），有序映照（ordered maps），时间戳记（timestamps）以及十六进制数据（hexadecimal）。</p>
]]></content>
      <categories>
        <category>web前端</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>博客页面模板的建立方法</title>
    <url>/2021/11/05/%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%BB%BA%E7%AB%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>使用hexo+github搭建免费个人静态博客，用markdown撰写博客，用hexo的页面模板会节省许多时间，本文就如何建立页面模板做介绍。</p>
<span id="more"></span>

<h3 id="1-hexo页面模板的存放位置"><a href="#1-hexo页面模板的存放位置" class="headerlink" title="1. hexo页面模板的存放位置"></a>1. hexo页面模板的存放位置</h3><p>在你建立博客目录的<code>\scaffolds</code>文件夹下有个<code>post.md</code>文件，此文件就是页面模板文件。</p>
<h3 id="2-hexo页面模板的建立方法"><a href="#2-hexo页面模板的建立方法" class="headerlink" title="2. hexo页面模板的建立方法"></a>2. hexo页面模板的建立方法</h3><ul>
<li><p>页面模板文件的建立就是修改<code>post.md</code>文件，用markdown打开这个文件进行编辑。</p>
</li>
<li><p>在’post.md’文件里添加如下内容：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">categories: </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">tags: </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">update: &#123;&#123; date &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>





<ul>
<li><p>title：标题</p>
</li>
<li><p>categories：分类</p>
</li>
<li><p>tags：标签</p>
</li>
<li><p>date：日期</p>
</li>
</ul>
<p><font color=red>注意：上面的代码使用yml格式的语言写的，<strong>注意冒号“:”后面必须要有空格和缩进空格</strong>， <a href="https://51228.github.io/2021/05/22/yaml%E8%AF%AD%E6%B3%95/">yaml</a></font></p>
<h3 id="3-hexo页面模板使用方法"><a href="#3-hexo页面模板使用方法" class="headerlink" title="3. hexo页面模板使用方法"></a>3. hexo页面模板使用方法</h3><ul>
<li>进入<code>\scaffolds</code>的同级目录以下。</li>
<li>输入<code>hexo new &quot;文章标题&quot;</code>，会在<code>\source\_posts</code>目录下生成你刚才输入标题的<code>.md</code>文件。</li>
<li>编辑categories和tags，注意短横后面要有空格。</li>
<li>编辑正文。</li>
</ul>
<blockquote>
<h4 id="在正文之前加上-lt-more-gt-，在-lt-more-gt-上面写文章摘要，博客不会把文章的内容全部显示出来了，只会显示每篇文章的摘要内容。"><a href="#在正文之前加上-lt-more-gt-，在-lt-more-gt-上面写文章摘要，博客不会把文章的内容全部显示出来了，只会显示每篇文章的摘要内容。" class="headerlink" title="在正文之前加上&lt;!-- more --&gt;，在&lt;!-- more --&gt;上面写文章摘要，博客不会把文章的内容全部显示出来了，只会显示每篇文章的摘要内容。"></a>在正文之前加上<code>&lt;!-- more --&gt;</code>，在<code>&lt;!-- more --&gt;</code>上面写文章摘要，博客不会把文章的内容全部显示出来了，只会显示每篇文章的摘要内容。</h4></blockquote>
<h5 id="完整的模板格式如下："><a href="#完整的模板格式如下：" class="headerlink" title="完整的模板格式如下："></a>完整的模板格式如下：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">categories: </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">tags: </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">  - </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">update: &#123;&#123; date &#125;&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>如何将文件夹固定到Windows任务栏</title>
    <url>/2021/06/24/%E5%A6%82%E4%BD%95%E5%B0%86%E6%96%87%E4%BB%B6%E5%A4%B9%E5%9B%BA%E5%AE%9A%E5%88%B0Windows%E4%BB%BB%E5%8A%A1%E6%A0%8F/</url>
    <content><![CDATA[<p>经常频繁的用到某个文件夹，从盘符点进入麻烦而且又耽搁时间，我们直接把频繁用到的文件夹固定到桌面任务栏，就很方便的来进行我们的操作。</p>
<span id="more"></span>

<hr>
<p>Windows不允许您将文件夹直接固定到任务栏。 不过，有一个简单的解决方法。 您要做的就是为文件夹创建一个新的快捷方式，然后将该快捷方式固定在任务栏上。</p>
<p>具体步骤如下：</p>
<ol>
<li><p>右键单击桌面上或文件浏览器中的任意位置，然后从上下文菜单中选择“新建&gt;快捷方式”。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624153145.png" alt="image-20210624153138112"></p>
</li>
<li><p>“创建快捷方式”向导的第一页上，单击“浏览”按钮以找到要固定的文件夹。 但是，选择文件夹后，请不要单击“下一步”。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624153713.png" alt="image-20210624153713114"></p>
</li>
<li><p>现在添加“ Explorer”(不带引号)，然后在您选择的文件夹路径之前添加一个空格。 之后，继续并单击“下一步”按钮。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624153835.png" alt="image-20210624153835259"></p>
</li>
<li><p>输入快捷方式的名称，然后单击“完成”以在您选择的位置创建快捷方式。</p>
</li>
<li><p>更改快捷方式的图标。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624154248.png" alt="image-20210624154248814"></p>
</li>
<li><p>把图标拖到任务栏将其固定，删除桌面的快捷方式任务栏的文件夹快捷方式就建立好了。</p>
<p><img src="https://gitee.com/nsaction/blog_pic/raw/master/20210624155528.png" alt="image-20210624155528477"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>windows</category>
        <category>快捷方式</category>
      </categories>
      <tags>
        <tag>任务栏</tag>
        <tag>文件夹</tag>
      </tags>
  </entry>
  <entry>
    <title>常用电线电缆型号含义</title>
    <url>/2021/11/04/%E5%B8%B8%E7%94%A8%E7%94%B5%E7%BA%BF%E7%94%B5%E7%BC%86%E5%9E%8B%E5%8F%B7%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<p>本文通过在网上寻找资料，自己整理的电线电缆的型号含义，以便在日常工作中使用。</p>
<span id="more"></span>

<h1 id="电缆的型号表示含义："><a href="#电缆的型号表示含义：" class="headerlink" title="电缆的型号表示含义："></a>电缆的型号表示含义：</h1><ul>
<li><p>一、用途代码－不标为电力电缆，K为控制缆，P为信号缆;W无卤，D低烟，Z阻燃，N耐火，B代表的含义是布线用电线，。    </p>
</li>
<li><p>二、绝缘代码－Z油浸纸，X橡胶，V聚氯乙烯，YJ交联聚乙烯（Y表示聚乙烯，J表示交联），B－平型（扁形），S－双绞型；    </p>
</li>
<li><p>三、导体材料代码－不标为铜，L为铝;R－连接用软电缆（电线），软结构；    </p>
</li>
<li><p>四、内护层代码－Q铅包，L铝包，H橡套，V聚氯乙烯护套，E在电线电缆命名代号里表示聚乙烯。F表示辐照，P－编织屏蔽、P2－铜带屏蔽、P22－钢带铠装；    </p>
</li>
<li><p>五、派生代码－D不滴流，P干绝缘;    </p>
</li>
<li><p>六、外护层代码-E在电线电缆命名代号里表示聚乙烯。F表示辐照，P－编织屏蔽、P2－铜带屏蔽、P22－钢带铠装；    </p>
</li>
<li><p>七、特殊产品代码－TH湿热带，TA干热带;    </p>
</li>
<li><p>八、额定电压－单位KV</p>
</li>
</ul>
<p>​    </p>
<h4 id="数字标记-铠装层-外被层或外护套"><a href="#数字标记-铠装层-外被层或外护套" class="headerlink" title="数字标记 铠装层 外被层或外护套"></a>数字标记 铠装层 外被层或外护套</h4><ul>
<li><p>0  无 —    </p>
</li>
<li><p>1  联锁铠装 纤维外被    </p>
</li>
<li><p>2  双层钢带 聚氯乙烯外套    </p>
</li>
<li><p>3  细圆钢丝 聚乙烯外套    </p>
</li>
<li><p>4  粗圆钢丝    </p>
</li>
<li><p>5  皱纹(轧纹)钢带    </p>
</li>
<li><p>6  双铝(或铝合金)带    </p>
</li>
<li><p>8  铜丝编织    </p>
</li>
<li><p>9  钢丝编织</p>
</li>
</ul>
<p>​    </p>
<h3 id="电缆的型号组成与顺序："><a href="#电缆的型号组成与顺序：" class="headerlink" title="电缆的型号组成与顺序："></a>电缆的型号组成与顺序：</h3><ul>
<li><p>1:类别、用途 2:导体 3: 绝缘4:内护层 5:结构特征 6:外护层或派生 7:使用特征    </p>
</li>
<li><p>1-5项和第7项用拼音字母表示，高分子材料用英文名的第1位字母表示，每项可以是1-2个字母；第6项是1-3个数字。    </p>
</li>
<li><p>型号中的省略原则：电线电缆产品中铜是主要使用的导体材料，故铜芯代号T省写，但裸电线及裸导体制品除外。裸电线及裸导体制品类、电力电缆类、电磁线类产品不表明大类代号，电气装备用电线电缆类和通信电缆类也不列明，但列明小类或系列代号等。    </p>
</li>
<li><p>第7项是各种特殊使用场合或附加特殊使用要求的标记，在“-”后以拼音字母标记。有时为了突出该项，把此项写到最前面。如ZR-(阻燃)、NH-(耐火)、WDZ-(低烟无卤、企业标准)、-TH(湿热地区用)、FY-(防白蚁、企业标准)等。</p>
</li>
</ul>
<h4 id="电缆型号选型注意事项"><a href="#电缆型号选型注意事项" class="headerlink" title="电缆型号选型注意事项"></a>电缆型号选型注意事项</h4><ul>
<li><p>1、SYV：实心聚乙烯绝缘射频同轴电缆    </p>
</li>
<li><p>2、SYWV(Y)：物理发泡聚乙绝缘有线电视系统电缆，视频（射频）同轴电缆（SYV、SYWV、SYFV）适用于闭路监控及有线电视工程    </p>
</li>
<li><p>SYWV（Y）、SYKV 有线电视、宽带网专用电缆 结构：（同轴电缆）单根无氧圆铜线+物理 发泡聚乙烯（绝缘）+（锡丝+铝）+聚氯乙烯（聚乙烯）    </p>
</li>
<li><p>3、信号控制电缆（RVV护套线、RVVP屏蔽线）适用于楼宇对讲、防盗报警、消防、自动抄表等工程    </p>
</li>
<li><p>RVVP：铜芯聚氯乙烯绝缘屏蔽聚氯乙烯护套软电缆 电压300V&#x2F;300V 2-24芯    </p>
</li>
<li><p>用途：仪器、仪表、对讲、监控、控制安装    </p>
</li>
<li><p>4、RG：物理发泡聚乙烯绝缘接入网电缆 用于同轴光纤混合网（HFC）中传输数据模拟信号    </p>
</li>
<li><p>5、KVVP：聚氯乙烯护套编织屏蔽电缆 用途：电器、仪表、配电装置的信号传输、控制、测量    </p>
</li>
<li><p>6、RVV（227IEC52&#x2F;53） 聚氯乙烯绝缘软电缆 用途：家用电器、小型电动工具、仪表及动 力照明    </p>
</li>
<li><p>7、AVVR 聚氯乙烯护套安装用软电缆    </p>
</li>
<li><p>8、SBVV HYA 数据通信电缆（室内、外）用于电话通信及无线电设备的连接以及电话配线网的 分线盒接线用    </p>
</li>
<li><p>9、RV、RVP 聚氯乙烯绝缘电缆    </p>
</li>
<li><p>10、RVS、RVB 适用于家用电器、小型电动工具、仪器、仪表及动力照明连接用电缆    </p>
</li>
<li><p>11、BV、BVR 聚氯乙烯绝缘电缆 用途：适用于电器仪表设备及动力照明固定布线用    </p>
</li>
<li><p>12、RIB 音箱连接线（发烧线）    </p>
</li>
<li><p>13、KVV 聚氯乙烯绝缘控制电缆 用途：电器、仪表、配电装置信号传输、控制、测量    </p>
</li>
<li><p>14、SFTP 双绞线 传输电话、数据及信息网    </p>
</li>
<li><p>15、UL2464 电脑连接线    </p>
</li>
<li><p>16、VGA 显示器线    </p>
</li>
<li><p>17、SYV 同轴电缆 无线通讯、广播、监控系统工程和有关电子设备中传输射频信号（含综合用同轴电缆）    </p>
</li>
<li><p>18、SDFAVP、SDFAVVP、SYFPY 同轴电缆，电梯专用    </p>
</li>
<li><p>19、JVPV、JVPVP、JVVP 铜芯聚氯乙烯绝缘及护套铜丝编织电子计算机控制电缆    </p>
</li>
<li><p>所有消防用电设备线路均采用阻燃或耐火导线，    </p>
</li>
<li><p>电力干线采用WDZ-YJ(F)E-0.6&#x2F;1kV型低烟无卤阻燃耐火电力电缆,（消防用电为矿物绝缘电缆）。    </p>
</li>
<li><p>由末端配电箱引出的分支线采用WDZ-BYJ(F)-450&#x2F;750V型铜芯线(消防为WDZN-BYJ(F))。</p>
</li>
</ul>
<h4 id="常用的举例"><a href="#常用的举例" class="headerlink" title="常用的举例"></a>常用的举例</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h5 id="W-DZ-低-烟-无-卤阻-燃-电-缆"><a href="#W-DZ-低-烟-无-卤阻-燃-电-缆" class="headerlink" title="W DZ - 低 烟 无 卤阻 燃 电 缆"></a>W DZ - 低 烟 无 卤阻 燃 电 缆</h5><ul>
<li><p>WDZAN–低烟无卤A级阻燃耐火电缆（W-无卤；D–低烟；Z–阻燃；A-级别；N-耐火）    </p>
</li>
<li><p>BYJ是铜芯交联聚乙烯绝缘电线    </p>
</li>
<li><p>BYJ(F)—铜芯导体辐照交联聚乙烯绝缘固定敷设用电线    </p>
</li>
<li><p>全称是：低烟无卤A级阻燃耐火铜芯导体辐照交联聚乙烯绝缘固定敷设用电线    </p>
</li>
<li><p>WDZ表示无卤低烟阻燃</p>
</li>
</ul>
<p>​    </p>
<h5 id="YJV22是交联-聚氯乙烯绝缘-铠装电缆"><a href="#YJV22是交联-聚氯乙烯绝缘-铠装电缆" class="headerlink" title="YJV22是交联 聚氯乙烯绝缘 铠装电缆"></a>YJV22是交联 聚氯乙烯绝缘 铠装电缆</h5><ul>
<li><p>YJ：表示交联聚乙烯绝缘，Y表示聚乙烯，J表示交联    </p>
</li>
<li><p>V：聚氯乙烯绝缘材料    </p>
</li>
<li><p>22：铠装    </p>
</li>
<li><p>交联聚乙烯绝缘钢带铠装聚氯乙烯护套电缆用于工频交流电压500kv及以下的输配电线路中，适用于地埋敷设，能承受机械外力作用，但不能承受大的压力    </p>
<p>​    </p>
</li>
<li><p>交联聚乙烯绝缘电缆是一种适用于配电网等领域的电缆，具有PVC绝缘电缆无法比拟的优点。它结构简单、重量轻、耐热好、负载能力强、不熔化、耐化学腐蚀，机械强度高。    </p>
<p>​    </p>
</li>
<li><p>交联聚乙烯绝缘电缆是利用化学方法或物理方法，使电缆绝缘聚乙烯分子由线性分子结构转变为主体网状分子结构，即热塑性的聚乙烯转变为热固性的交联聚乙烯，从而大大提高它的耐热性和机械性能，减少了它的收缩性，使其受热以后不再熔化，并保持了优良的电气性能。</p>
</li>
</ul>
<p>​    </p>
<h5 id="RVS-x2F-BVS"><a href="#RVS-x2F-BVS" class="headerlink" title="RVS&#x2F;BVS"></a>RVS&#x2F;BVS</h5><ul>
<li><p>R－连接用软电缆（电线），软结构。    </p>
</li>
<li><p>V－绝缘聚氯乙烯。    </p>
</li>
<li><p>B－平型（扁形）B固定布线用电缆（电线）    </p>
</li>
<li><p>S－双绞型。A－镀锡或镀银    </p>
</li>
<li><p>1、BV：PVC电线，只有一根铜线的单芯线，比较硬。    </p>
</li>
<li><p>2、BVR：PVC电线，好多股铜丝绞在一起的单芯线，较软。    </p>
</li>
<li><p>3、RV：PVC电线，更多股铜丝绞在一起的单芯线，极软。    型号</p>
</li>
</ul>
<h5 id="BTTVZ是重型铜芯铜护套聚氯乙烯外护套矿物绝缘电缆"><a href="#BTTVZ是重型铜芯铜护套聚氯乙烯外护套矿物绝缘电缆" class="headerlink" title="BTTVZ是重型铜芯铜护套聚氯乙烯外护套矿物绝缘电缆"></a>BTTVZ是重型铜芯铜护套聚氯乙烯外护套矿物绝缘电缆</h5><p>​    </p>
<p>​    <img src="https://gitee.com/nsaction/blog_pic/raw/master/20211104114155.png" alt="image-20211104114148260"></p>
<p>​    </p>
<h5 id="线缆铺设字母含义"><a href="#线缆铺设字母含义" class="headerlink" title="线缆铺设字母含义"></a>线缆铺设字母含义</h5><ul>
<li><p>CT:沿桥架或托盘敷设    ··</p>
</li>
<li><p>SC20:线缆穿直径20mm的钢管敷设;    </p>
</li>
<li><p>CC:暗敷在屋面内或顶棚内;    </p>
</li>
<li><p>PC20:需要穿外径20毫米的阻燃PVC塑料管或者穿管后埋在墙里走线。    </p>
</li>
<li><p>FC,WC是线槽及线管沿地面或墙体暗敷    </p>
</li>
<li><p>ACC:是沿棚暗敷设。    </p>
</li>
<li><p>CE:沿天棚顶敷设    </p>
</li>
<li><p>WC:暗敷设在墙内    </p>
</li>
<li><p>MR&#x2F;JDG20:是沿MR(金属线槽),JDG20(紧定式金属直径20的电线管)敷设,    </p>
</li>
<li><p>JDG20:是20的焊接钢管。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>电线</category>
        <category>电缆</category>
      </categories>
      <tags>
        <tag>型号含义</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机编码</title>
    <url>/2021/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>经常遇到Unicode和UTF-8，具体是什么意思，他们之间有什么区别呢？本编文章简要的解密计算机编码问题</p>
<span id="more"></span>

<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><ul>
<li>最早，127个字符被编码到计算机里，也就是大小写英文字母,数字及一些符号，这个编码表被称为ASCII编码</li>
</ul>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>全世界有上百种语言，Unicode把所有语言都统一到一套编码里，这样就不会有乱码问题了。</p>
<h2 id="ASCII编码和Unicode编码的区别："><a href="#ASCII编码和Unicode编码的区别：" class="headerlink" title="ASCII编码和Unicode编码的区别："></a>ASCII编码和Unicode编码的区别：</h2><ul>
<li>ASCII编码是1个字节</li>
<li>Unicode编码通常是两个字节。</li>
<li>字母A用ASCII编码是十进制的65，二进制的01000001。</li>
<li>如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此A的Unicode编码是00000000 01000001。</li>
<li>如果统一成Unicode编码，但是用Unicode编码比ASCII编码多一倍存储空间，在存储和传输上十分不划算。</li>
</ul>
<h1 id="本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。"><a href="#本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。" class="headerlink" title="本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。"></a>本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。</h1><ul>
<li>UTF-8编码把一个Unicode字符根据不同的数字大小编码成1～6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节</li>
<li>计算机系统通用的字符编码工作方式：在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或需要传输时，可以转换为UTF-8编码。</li>
</ul>
]]></content>
      <categories>
        <category>小知识</category>
        <category>编码</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
      </tags>
  </entry>
</search>
